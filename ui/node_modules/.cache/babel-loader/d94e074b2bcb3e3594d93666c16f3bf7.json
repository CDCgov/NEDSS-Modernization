{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport { isEnumType, isInputObjectType, isInputType, isInterfaceType, isNamedType, isNonNullType, isObjectType, isOutputType, isRequiredArgument, isRequiredInputField, isUnionType } from './definition.mjs';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { assertSchema } from './schema.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(new GraphQLError(message, {\n      nodes: _nodes\n    }));\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n  schemaNode => {\n    var _schemaNode$operation;\n\n    return (\n      /* c8 ignore next */\n      (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []\n    );\n  }).find(operationNode => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(`Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`, node.astNode);\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(`Expected GraphQL named type but got: ${inspect(type)}.`, type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [type.astNode, ...type.extensionASTNodes]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(`Type ${inspect(type)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [(_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find(arg => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [(_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n\n    } // Assert additional arguments must not be required.\n\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find(arg => arg.name === argName);\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [...getAllImplementsInterfaceNodes(iface, transitive), ...getAllImplementsInterfaceNodes(type, iface)]);\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);\n  } // Ensure the arguments are valid\n\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [getDeprecatedDirectiveNode(field.astNode), (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map(fieldObj => fieldObj.name).join('.');\n          context.reportError(`Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`, cyclePath.map(fieldObj => fieldObj.astNode));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = type;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(typeNode => {\n    var _typeNode$interfaces;\n\n    return (\n      /* c8 ignore next */\n      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []\n    );\n  }).filter(ifaceNode => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = union;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(unionNode => {\n    var _unionNode$types;\n\n    return (\n      /* c8 ignore next */\n      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []\n    );\n  }).filter(typeNode => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(node => node.name.value === GraphQLDeprecatedDirective.name);\n}","map":{"version":3,"names":["inspect","GraphQLError","OperationTypeNode","isEqualType","isTypeSubTypeOf","isEnumType","isInputObjectType","isInputType","isInterfaceType","isNamedType","isNonNullType","isObjectType","isOutputType","isRequiredArgument","isRequiredInputField","isUnionType","GraphQLDeprecatedDirective","isDirective","isIntrospectionType","assertSchema","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","constructor","_errors","reportError","nodes","_nodes","Array","isArray","filter","Boolean","push","queryType","getQueryType","astNode","_getOperationTypeNode","getOperationTypeNode","QUERY","mutationType","getMutationType","_getOperationTypeNode2","MUTATION","subscriptionType","getSubscriptionType","_getOperationTypeNode3","SUBSCRIPTION","operation","_flatMap$find","extensionASTNodes","flatMap","schemaNode","_schemaNode$operation","operationTypes","find","operationNode","type","directive","getDirectives","validateName","arg","args","name","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","node","startsWith","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","Object","values","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","field","_field$astNode","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","create","iface","getInterfaces","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","ifaceField","fieldName","typeField","_ifaceField$astNode","_typeField$astNode","ifaceArg","typeArg","_ifaceArg$astNode","_typeArg$astNode","ifaceInterfaces","transitive","includes","union","memberTypes","getTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","enumValue","inputObj","_field$astNode2","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","ofType","fieldType","cycleIndex","undefined","cyclePath","slice","pathStr","fieldObj","pop","typeNode","_typeNode$interfaces","interfaces","ifaceNode","value","typeName","unionNode","_unionNode$types","types","definitionNode","_definitionNode$direc","directives"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/type/validate.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInputType,\n  isInterfaceType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isOutputType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isUnionType,\n} from './definition.mjs';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { assertSchema } from './schema.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(\n      new GraphQLError(message, {\n        nodes: _nodes,\n      }),\n    );\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\n      `Query root type must be Object type, it cannot be ${inspect(\n        queryType,\n      )}.`,\n      (_getOperationTypeNode = getOperationTypeNode(\n        schema,\n        OperationTypeNode.QUERY,\n      )) !== null && _getOperationTypeNode !== void 0\n        ? _getOperationTypeNode\n        : queryType.astNode,\n    );\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError(\n      'Mutation root type must be Object type if provided, it cannot be ' +\n        `${inspect(mutationType)}.`,\n      (_getOperationTypeNode2 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.MUTATION,\n      )) !== null && _getOperationTypeNode2 !== void 0\n        ? _getOperationTypeNode2\n        : mutationType.astNode,\n    );\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError(\n      'Subscription root type must be Object type if provided, it cannot be ' +\n        `${inspect(subscriptionType)}.`,\n      (_getOperationTypeNode3 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.SUBSCRIPTION,\n      )) !== null && _getOperationTypeNode3 !== void 0\n        ? _getOperationTypeNode3\n        : subscriptionType.astNode,\n    );\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (schemaNode) => {\n        var _schemaNode$operation;\n\n        return (\n          /* c8 ignore next */\n          (_schemaNode$operation =\n            schemaNode === null || schemaNode === void 0\n              ? void 0\n              : schemaNode.operationTypes) !== null &&\n            _schemaNode$operation !== void 0\n            ? _schemaNode$operation\n            : []\n        );\n      },\n    )\n    .find((operationNode) => operationNode.operation === operation)) === null ||\n    _flatMap$find === void 0\n    ? void 0\n    : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\n        `Expected directive but got: ${inspect(directive)}.`,\n        directive === null || directive === void 0 ? void 0 : directive.astNode,\n      );\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\n          `The type of @${directive.name}(${arg.name}:) must be Input Type ` +\n            `but got: ${inspect(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(\n          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0\n              ? void 0\n              : _arg$astNode.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs =\n    createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${inspect(type)}.`,\n        type.astNode,\n      );\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\n        `The type of ${type.name}.${field.name} must be Output Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode = field.astNode) === null || _field$astNode === void 0\n          ? void 0\n          : _field$astNode.type,\n      );\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\n          `The type of ${type.name}.${field.name}(${argName}:) must be Input ` +\n            `Type but got: ${inspect(arg.type)}.`,\n          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0\n            ? void 0\n            : _arg$astNode2.type,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(\n          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0\n              ? void 0\n              : _arg$astNode3.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(\n        `Type ${inspect(type)} must only implement Interface types, ` +\n          `it cannot implement ${inspect(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type.name} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\n        `Type ${type.name} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` +\n          `is type ${inspect(typeField.type)}.`,\n        [\n          (_ifaceField$astNode = ifaceField.astNode) === null ||\n          _ifaceField$astNode === void 0\n            ? void 0\n            : _ifaceField$astNode.type,\n          (_typeField$astNode = typeField.astNode) === null ||\n          _typeField$astNode === void 0\n            ? void 0\n            : _typeField$astNode.type,\n        ],\n      );\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${inspect(ifaceArg.type)} but ` +\n            `${type.name}.${fieldName}(${argName}:) is type ` +\n            `${inspect(typeArg.type)}.`,\n          [\n            (_ifaceArg$astNode = ifaceArg.astNode) === null ||\n            _ifaceArg$astNode === void 0\n              ? void 0\n              : _ifaceArg$astNode.type,\n            (_typeArg$astNode = typeArg.astNode) === null ||\n            _typeArg$astNode === void 0\n              ? void 0\n              : _typeArg$astNode.type,\n          ],\n        );\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\n          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType.name} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${inspect(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType.name} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0\n          ? void 0\n          : _field$astNode2.type,\n      );\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\n        [\n          getDeprecatedDirectiveNode(field.astNode),\n          (_field$astNode3 = field.astNode) === null ||\n          _field$astNode3 === void 0\n            ? void 0\n            : _field$astNode3.type,\n        ],\n      );\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\n          context.reportError(\n            `Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const { astNode, extensionASTNodes } = type;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((typeNode) => {\n      var _typeNode$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_typeNode$interfaces = typeNode.interfaces) !== null &&\n          _typeNode$interfaces !== void 0\n          ? _typeNode$interfaces\n          : []\n      );\n    })\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const { astNode, extensionASTNodes } = union;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((unionNode) => {\n      var _unionNode$types;\n\n      return (\n        /* c8 ignore next */\n        (_unionNode$types = unionNode.types) !== null &&\n          _unionNode$types !== void 0\n          ? _unionNode$types\n          : []\n      );\n    })\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0\n    ? void 0\n    : (_definitionNode$direc = definitionNode.directives) === null ||\n      _definitionNode$direc === void 0\n    ? void 0\n    : _definitionNode$direc.find(\n        (node) => node.name.value === GraphQLDeprecatedDirective.name,\n      );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}