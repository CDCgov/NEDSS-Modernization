{"ast":null,"code":"/**\n * Contains a range of UTF-8 character offsets and token references that\n * identify the region of the source from which the AST derived.\n */\nexport class Location {\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The Token at which this Node begins.\n   */\n\n  /**\n   * The Token at which this Node ends.\n   */\n\n  /**\n   * The Source document the AST represents.\n   */\n  constructor(startToken, endToken, source) {\n    this.start = startToken.start;\n    this.end = endToken.end;\n    this.startToken = startToken;\n    this.endToken = endToken;\n    this.source = source;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Location';\n  }\n\n  toJSON() {\n    return {\n      start: this.start,\n      end: this.end\n    };\n  }\n\n}\n/**\n * Represents a range of characters represented by a lexical token\n * within a Source.\n */\n\nexport class Token {\n  /**\n   * The kind of Token.\n   */\n\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The 1-indexed line number on which this Token appears.\n   */\n\n  /**\n   * The 1-indexed column number at which this Token begins.\n   */\n\n  /**\n   * For non-punctuation tokens, represents the interpreted value of the token.\n   *\n   * Note: is undefined for punctuation tokens, but typed as string for\n   * convenience in the parser.\n   */\n\n  /**\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\n   * including ignored tokens. <SOF> is always the first node and <EOF>\n   * the last.\n   */\n  constructor(kind, start, end, line, column, value) {\n    this.kind = kind;\n    this.start = start;\n    this.end = end;\n    this.line = line;\n    this.column = column; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Token';\n  }\n\n  toJSON() {\n    return {\n      kind: this.kind,\n      value: this.value,\n      line: this.line,\n      column: this.column\n    };\n  }\n\n}\n/**\n * The list of all possible AST node types.\n */\n\n/**\n * @internal\n */\n\nexport const QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are deprecated and will removed in v17.0.0\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['description', 'directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nconst kindValues = new Set(Object.keys(QueryDocumentKeys));\n/**\n * @internal\n */\n\nexport function isNode(maybeNode) {\n  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;\n  return typeof maybeKind === 'string' && kindValues.has(maybeKind);\n}\n/** Name */\n\nvar OperationTypeNode;\n\n(function (OperationTypeNode) {\n  OperationTypeNode['QUERY'] = 'query';\n  OperationTypeNode['MUTATION'] = 'mutation';\n  OperationTypeNode['SUBSCRIPTION'] = 'subscription';\n})(OperationTypeNode || (OperationTypeNode = {}));\n\nexport { OperationTypeNode };","map":{"version":3,"names":["Location","constructor","startToken","endToken","source","start","end","Symbol","toStringTag","toJSON","Token","kind","line","column","value","prev","next","QueryDocumentKeys","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","kindValues","Set","Object","keys","isNode","maybeNode","maybeKind","has","OperationTypeNode"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/language/ast.mjs"],"sourcesContent":["/**\n * Contains a range of UTF-8 character offsets and token references that\n * identify the region of the source from which the AST derived.\n */\nexport class Location {\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The Token at which this Node begins.\n   */\n\n  /**\n   * The Token at which this Node ends.\n   */\n\n  /**\n   * The Source document the AST represents.\n   */\n  constructor(startToken, endToken, source) {\n    this.start = startToken.start;\n    this.end = endToken.end;\n    this.startToken = startToken;\n    this.endToken = endToken;\n    this.source = source;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Location';\n  }\n\n  toJSON() {\n    return {\n      start: this.start,\n      end: this.end,\n    };\n  }\n}\n/**\n * Represents a range of characters represented by a lexical token\n * within a Source.\n */\n\nexport class Token {\n  /**\n   * The kind of Token.\n   */\n\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The 1-indexed line number on which this Token appears.\n   */\n\n  /**\n   * The 1-indexed column number at which this Token begins.\n   */\n\n  /**\n   * For non-punctuation tokens, represents the interpreted value of the token.\n   *\n   * Note: is undefined for punctuation tokens, but typed as string for\n   * convenience in the parser.\n   */\n\n  /**\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\n   * including ignored tokens. <SOF> is always the first node and <EOF>\n   * the last.\n   */\n  constructor(kind, start, end, line, column, value) {\n    this.kind = kind;\n    this.start = start;\n    this.end = end;\n    this.line = line;\n    this.column = column; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Token';\n  }\n\n  toJSON() {\n    return {\n      kind: this.kind,\n      value: this.value,\n      line: this.line,\n      column: this.column,\n    };\n  }\n}\n/**\n * The list of all possible AST node types.\n */\n\n/**\n * @internal\n */\nexport const QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: [\n    'name',\n    'variableDefinitions',\n    'directives',\n    'selectionSet',\n  ],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: [\n    'name', // Note: fragment variable definitions are deprecated and will removed in v17.0.0\n    'variableDefinitions',\n    'typeCondition',\n    'directives',\n    'selectionSet',\n  ],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['description', 'directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: [\n    'description',\n    'name',\n    'interfaces',\n    'directives',\n    'fields',\n  ],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: [\n    'description',\n    'name',\n    'type',\n    'defaultValue',\n    'directives',\n  ],\n  InterfaceTypeDefinition: [\n    'description',\n    'name',\n    'interfaces',\n    'directives',\n    'fields',\n  ],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields'],\n};\nconst kindValues = new Set(Object.keys(QueryDocumentKeys));\n/**\n * @internal\n */\n\nexport function isNode(maybeNode) {\n  const maybeKind =\n    maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;\n  return typeof maybeKind === 'string' && kindValues.has(maybeKind);\n}\n/** Name */\n\nvar OperationTypeNode;\n\n(function (OperationTypeNode) {\n  OperationTypeNode['QUERY'] = 'query';\n  OperationTypeNode['MUTATION'] = 'mutation';\n  OperationTypeNode['SUBSCRIPTION'] = 'subscription';\n})(OperationTypeNode || (OperationTypeNode = {}));\n\nexport { OperationTypeNode };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}