{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\n\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    var _iterator = _createForOfIteratorHelper(spreadNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var spreadNode = _step.value;\n        var spreadName = spreadNode.name.value;\n        var cycleIndex = spreadPathIndexByName[spreadName];\n        spreadPath.push(spreadNode);\n\n        if (cycleIndex === undefined) {\n          var spreadFragment = context.getFragment(spreadName);\n\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        } else {\n          var cyclePath = spreadPath.slice(cycleIndex);\n          var viaPath = cyclePath.slice(0, -1).map(function (s) {\n            return '\"' + s.name.value + '\"';\n          }).join(', ');\n          context.reportError(new GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), {\n            nodes: cyclePath\n          }));\n        }\n\n        spreadPath.pop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}","map":{"version":3,"names":["GraphQLError","NoFragmentCyclesRule","context","visitedFrags","Object","create","spreadPath","spreadPathIndexByName","OperationDefinition","FragmentDefinition","node","detectCycleRecursive","fragment","name","value","fragmentName","spreadNodes","getFragmentSpreads","selectionSet","length","spreadNode","spreadName","cycleIndex","push","undefined","spreadFragment","getFragment","cyclePath","slice","viaPath","map","s","join","reportError","nodes","pop"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n"],"mappings":";AAAA,SAASA,YAAT,QAA6B,8BAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,oBAAT,CAA8BC,OAA9B,EAAuC;EAC5C;EACA;EACA,IAAMC,YAAY,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAArB,CAH4C,CAGF;;EAE1C,IAAMC,UAAU,GAAG,EAAnB,CAL4C,CAKrB;;EAEvB,IAAMC,qBAAqB,GAAGH,MAAM,CAACC,MAAP,CAAc,IAAd,CAA9B;EACA,OAAO;IACLG,mBAAmB,EAAE;MAAA,OAAM,KAAN;IAAA,CADhB;IAGLC,kBAHK,8BAGcC,IAHd,EAGoB;MACvBC,oBAAoB,CAACD,IAAD,CAApB;MACA,OAAO,KAAP;IACD;EANI,CAAP,CAR4C,CAezC;EACH;EACA;;EAEA,SAASC,oBAAT,CAA8BC,QAA9B,EAAwC;IACtC,IAAIT,YAAY,CAACS,QAAQ,CAACC,IAAT,CAAcC,KAAf,CAAhB,EAAuC;MACrC;IACD;;IAED,IAAMC,YAAY,GAAGH,QAAQ,CAACC,IAAT,CAAcC,KAAnC;IACAX,YAAY,CAACY,YAAD,CAAZ,GAA6B,IAA7B;IACA,IAAMC,WAAW,GAAGd,OAAO,CAACe,kBAAR,CAA2BL,QAAQ,CAACM,YAApC,CAApB;;IAEA,IAAIF,WAAW,CAACG,MAAZ,KAAuB,CAA3B,EAA8B;MAC5B;IACD;;IAEDZ,qBAAqB,CAACQ,YAAD,CAArB,GAAsCT,UAAU,CAACa,MAAjD;;IAbsC,2CAebH,WAfa;IAAA;;IAAA;MAetC,oDAAsC;QAAA,IAA3BI,UAA2B;QACpC,IAAMC,UAAU,GAAGD,UAAU,CAACP,IAAX,CAAgBC,KAAnC;QACA,IAAMQ,UAAU,GAAGf,qBAAqB,CAACc,UAAD,CAAxC;QACAf,UAAU,CAACiB,IAAX,CAAgBH,UAAhB;;QAEA,IAAIE,UAAU,KAAKE,SAAnB,EAA8B;UAC5B,IAAMC,cAAc,GAAGvB,OAAO,CAACwB,WAAR,CAAoBL,UAApB,CAAvB;;UAEA,IAAII,cAAJ,EAAoB;YAClBd,oBAAoB,CAACc,cAAD,CAApB;UACD;QACF,CAND,MAMO;UACL,IAAME,SAAS,GAAGrB,UAAU,CAACsB,KAAX,CAAiBN,UAAjB,CAAlB;UACA,IAAMO,OAAO,GAAGF,SAAS,CACtBC,KADa,CACP,CADO,EACJ,CAAC,CADG,EAEbE,GAFa,CAET,UAACC,CAAD;YAAA,OAAO,MAAMA,CAAC,CAAClB,IAAF,CAAOC,KAAb,GAAqB,GAA5B;UAAA,CAFS,EAGbkB,IAHa,CAGR,IAHQ,CAAhB;UAIA9B,OAAO,CAAC+B,WAAR,CACE,IAAIjC,YAAJ,CACE,mCAA2BqB,UAA3B,yBACGQ,OAAO,KAAK,EAAZ,kBAAyBA,OAAzB,SAAsC,GADzC,CADF,EAGE;YACEK,KAAK,EAAEP;UADT,CAHF,CADF;QASD;;QAEDrB,UAAU,CAAC6B,GAAX;MACD;IA5CqC;MAAA;IAAA;MAAA;IAAA;;IA8CtC5B,qBAAqB,CAACQ,YAAD,CAArB,GAAsCS,SAAtC;EACD;AACF"},"metadata":{},"sourceType":"module"}