{"ast":null,"code":"import _slicedToArray from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport has from 'lodash/has'; // @ts-expect-error\n\nimport toposort from 'toposort';\nimport { split } from 'property-expr';\nimport Ref from '../Reference';\nimport isSchema from './isSchema';\nexport default function sortFields(fields) {\n  var excludedEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var edges = [];\n  var nodes = new Set();\n  var excludes = new Set(excludedEdges.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        a = _ref2[0],\n        b = _ref2[1];\n\n    return \"\".concat(a, \"-\").concat(b);\n  }));\n\n  function addNode(depPath, key) {\n    var node = split(depPath)[0];\n    nodes.add(node);\n    if (!excludes.has(\"\".concat(key, \"-\").concat(node))) edges.push([key, node]);\n  }\n\n  var _loop = function _loop(key) {\n    if (has(fields, key)) {\n      var value = fields[key];\n      nodes.add(key);\n      if (Ref.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(function (path) {\n        return addNode(path, key);\n      });\n    }\n  };\n\n  for (var key in fields) {\n    _loop(key);\n  }\n\n  return toposort.array(Array.from(nodes), edges).reverse();\n}","map":{"version":3,"names":["has","toposort","split","Ref","isSchema","sortFields","fields","excludedEdges","edges","nodes","Set","excludes","map","a","b","addNode","depPath","key","node","add","push","value","isRef","isSibling","path","deps","forEach","array","Array","from","reverse"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/yup/es/util/sortFields.js"],"sourcesContent":["import has from 'lodash/has'; // @ts-expect-error\n\nimport toposort from 'toposort';\nimport { split } from 'property-expr';\nimport Ref from '../Reference';\nimport isSchema from './isSchema';\nexport default function sortFields(fields, excludedEdges = []) {\n  let edges = [];\n  let nodes = new Set();\n  let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));\n\n  function addNode(depPath, key) {\n    let node = split(depPath)[0];\n    nodes.add(node);\n    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);\n  }\n\n  for (const key in fields) if (has(fields, key)) {\n    let value = fields[key];\n    nodes.add(key);\n    if (Ref.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));\n  }\n\n  return toposort.array(Array.from(nodes), edges).reverse();\n}"],"mappings":";AAAA,OAAOA,GAAP,MAAgB,YAAhB,C,CAA8B;;AAE9B,OAAOC,QAAP,MAAqB,UAArB;AACA,SAASC,KAAT,QAAsB,eAAtB;AACA,OAAOC,GAAP,MAAgB,cAAhB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,eAAe,SAASC,UAAT,CAAoBC,MAApB,EAAgD;EAAA,IAApBC,aAAoB,uEAAJ,EAAI;EAC7D,IAAIC,KAAK,GAAG,EAAZ;EACA,IAAIC,KAAK,GAAG,IAAIC,GAAJ,EAAZ;EACA,IAAIC,QAAQ,GAAG,IAAID,GAAJ,CAAQH,aAAa,CAACK,GAAd,CAAkB;IAAA;IAAA,IAAEC,CAAF;IAAA,IAAKC,CAAL;;IAAA,iBAAeD,CAAf,cAAoBC,CAApB;EAAA,CAAlB,CAAR,CAAf;;EAEA,SAASC,OAAT,CAAiBC,OAAjB,EAA0BC,GAA1B,EAA+B;IAC7B,IAAIC,IAAI,GAAGhB,KAAK,CAACc,OAAD,CAAL,CAAe,CAAf,CAAX;IACAP,KAAK,CAACU,GAAN,CAAUD,IAAV;IACA,IAAI,CAACP,QAAQ,CAACX,GAAT,WAAgBiB,GAAhB,cAAuBC,IAAvB,EAAL,EAAqCV,KAAK,CAACY,IAAN,CAAW,CAACH,GAAD,EAAMC,IAAN,CAAX;EACtC;;EAT4D,2BAWlDD,GAXkD;IAWnC,IAAIjB,GAAG,CAACM,MAAD,EAASW,GAAT,CAAP,EAAsB;MAC9C,IAAII,KAAK,GAAGf,MAAM,CAACW,GAAD,CAAlB;MACAR,KAAK,CAACU,GAAN,CAAUF,GAAV;MACA,IAAId,GAAG,CAACmB,KAAJ,CAAUD,KAAV,KAAoBA,KAAK,CAACE,SAA9B,EAAyCR,OAAO,CAACM,KAAK,CAACG,IAAP,EAAaP,GAAb,CAAP,CAAzC,KAAuE,IAAIb,QAAQ,CAACiB,KAAD,CAAR,IAAmB,UAAUA,KAAjC,EAAwCA,KAAK,CAACI,IAAN,CAAWC,OAAX,CAAmB,UAAAF,IAAI;QAAA,OAAIT,OAAO,CAACS,IAAD,EAAOP,GAAP,CAAX;MAAA,CAAvB;IAChH;EAf4D;;EAW7D,KAAK,IAAMA,GAAX,IAAkBX,MAAlB;IAAA,MAAWW,GAAX;EAAA;;EAMA,OAAOhB,QAAQ,CAAC0B,KAAT,CAAeC,KAAK,CAACC,IAAN,CAAWpB,KAAX,CAAf,EAAkCD,KAAlC,EAAyCsB,OAAzC,EAAP;AACD"},"metadata":{},"sourceType":"module"}