{"ast":null,"code":"import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(this._lexer.source, this._lexer.token.start, 'Unexpected description, descriptions are supported only on type definitions.');\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n\n  parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,\n      directives: this.parseConstDirectives()\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName()\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n\n  parseArgument() {\n    let isConst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false)\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n\n  parseFragmentDefinition() {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.allowLegacyFragmentVariables === true) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value\n        });\n\n      case TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this.advanceLexer();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(this._lexer.source, token.start, `Unexpected variable \"$${varName}\" in constant value.`);\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst)\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName()\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements') ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n\n  parseFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n\n  parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n\n  parseEnumValueName() {\n    if (this._lexer.token.value === 'true' || this._lexer.token.value === 'false' || this._lexer.token.value === 'null') {\n      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n\n  node(startToken, node) {\n    if (this._options.noLocation !== true) {\n      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, `Expected \"${value}\", found ${getTokenDesc(token)}.`);\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n\n  unexpected(atToken) {\n    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n  advanceLexer() {\n    const {\n      maxTokens\n    } = this._options;\n\n    const token = this._lexer.advance();\n\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n      ++this._tokenCounter;\n\n      if (this._tokenCounter > maxTokens) {\n        throw syntaxError(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);\n      }\n    }\n  }\n\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}","map":{"version":3,"names":["syntaxError","Location","OperationTypeNode","DirectiveLocation","Kind","isPunctuatorTokenKind","Lexer","isSource","Source","TokenKind","parse","source","options","parser","Parser","parseDocument","parseValue","expectToken","SOF","value","parseValueLiteral","EOF","parseConstValue","parseConstValueLiteral","parseType","type","parseTypeReference","constructor","sourceObj","_lexer","_options","_tokenCounter","parseName","token","NAME","node","kind","DOCUMENT","definitions","many","parseDefinition","peek","BRACE_L","parseOperationDefinition","hasDescription","peekDescription","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","start","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","QUERY","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","parseConstDirectives","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advanceLexer","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","varName","block","LIST","values","any","BRACKET_R","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","innerType","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","AMP","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","getTokenDesc","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","Object","prototype","hasOwnProperty","call","startToken","noLocation","loc","lastToken","getTokenKindDesc","atToken","openKind","parseFn","closeKind","nodes","delimiterKind","maxTokens","advance"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/language/parser.mjs"],"sourcesContent":["import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options = {}) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.allowLegacyFragmentVariables === true) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this.advanceLexer();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    if (this._options.noLocation !== true) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n  advanceLexer() {\n    const { maxTokens } = this._options;\n\n    const token = this._lexer.advance();\n\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n      ++this._tokenCounter;\n\n      if (this._tokenCounter > maxTokens) {\n        throw syntaxError(\n          this._lexer.source,\n          token.start,\n          `Document contains more that ${maxTokens} tokens. Parsing aborted.`,\n        );\n      }\n    }\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}