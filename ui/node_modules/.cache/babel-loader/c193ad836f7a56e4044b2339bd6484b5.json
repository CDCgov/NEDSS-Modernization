{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport { isEnumType, isInputObjectType, isInputType, isInterfaceType, isNamedType, isNonNullType, isObjectType, isOutputType, isRequiredArgument, isRequiredInputField, isUnionType } from './definition.mjs';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { assertSchema } from './schema.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    _classCallCheck(this, SchemaValidationContext);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  _createClass(SchemaValidationContext, [{\n    key: \"reportError\",\n    value: function reportError(message, nodes) {\n      var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n      this._errors.push(new GraphQLError(message, {\n        nodes: _nodes\n      }));\n    }\n  }, {\n    key: \"getErrors\",\n    value: function getErrors() {\n      return this._errors;\n    }\n  }]);\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), (_getOperationTypeNode = getOperationTypeNode(schema, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), (_getOperationTypeNode2 = getOperationTypeNode(schema, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), (_getOperationTypeNode3 = getOperationTypeNode(schema, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode].concat(_toConsumableArray(schema.extensionASTNodes)).flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n  function (schemaNode) {\n    var _schemaNode$operation;\n\n    return (\n      /* c8 ignore next */\n      (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []\n    );\n  }).find(function (operationNode) {\n    return operationNode.operation === operation;\n  })) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  var _iterator = _createForOfIteratorHelper(context.schema.getDirectives()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n\n      // Ensure all directives are in fact GraphQL directives.\n      if (!isDirective(directive)) {\n        context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive === null || directive === void 0 ? void 0 : directive.astNode);\n        continue;\n      } // Ensure they are named correctly.\n\n\n      validateName(context, directive); // TODO: Ensure proper locations.\n      // Ensure the arguments are valid.\n\n      var _iterator2 = _createForOfIteratorHelper(directive.args),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var arg = _step2.value;\n          // Ensure they are named correctly.\n          validateName(context, arg); // Ensure the type is an input type.\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(arg.name, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n          }\n\n          if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n            var _arg$astNode;\n\n            context.reportError(\"Required argument @\".concat(directive.name, \"(\").concat(arg.name, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\"Name \\\"\".concat(node.name, \"\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\"), node.astNode);\n  }\n}\n\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n\n  for (var _i = 0, _Object$values = Object.values(typeMap); _i < _Object$values.length; _i++) {\n    var type = _Object$values[_i];\n\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), [type.astNode].concat(_toConsumableArray(type.extensionASTNodes)));\n  }\n\n  for (var _i2 = 0, _fields = fields; _i2 < _fields.length; _i2++) {\n    var field = _fields[_i2];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    var _iterator3 = _createForOfIteratorHelper(field.args),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var arg = _step3.value;\n        var argName = arg.name; // Ensure they are named correctly.\n\n        validateName(context, arg); // Ensure the type is an input type\n\n        if (!isInputType(arg.type)) {\n          var _arg$astNode2;\n\n          context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n        }\n\n        if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n          var _arg$astNode3;\n\n          context.reportError(\"Required argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  var ifaceTypeNames = Object.create(null);\n\n  var _iterator4 = _createForOfIteratorHelper(type.getInterfaces()),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var iface = _step4.value;\n\n      if (!isInterfaceType(iface)) {\n        context.reportError(\"Type \".concat(inspect(type), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(type, iface));\n        continue;\n      }\n\n      if (type === iface) {\n        context.reportError(\"Type \".concat(type.name, \" cannot implement itself because it would create a circular reference.\"), getAllImplementsInterfaceNodes(type, iface));\n        continue;\n      }\n\n      if (ifaceTypeNames[iface.name]) {\n        context.reportError(\"Type \".concat(type.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(type, iface));\n        continue;\n      }\n\n      ifaceTypeNames[iface.name] = true;\n      validateTypeImplementsAncestors(context, type, iface);\n      validateTypeImplementsInterface(context, type, iface);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  var typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (var _i3 = 0, _Object$values2 = Object.values(iface.getFields()); _i3 < _Object$values2.length; _i3++) {\n    var ifaceField = _Object$values2[_i3];\n    var fieldName = ifaceField.name;\n    var typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(type.name, \" does not provide it.\"), [ifaceField.astNode, type.astNode].concat(_toConsumableArray(type.extensionASTNodes)));\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(type.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(typeField.type), \".\"), [(_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _iterator5 = _createForOfIteratorHelper(ifaceField.args),\n        _step5;\n\n    try {\n      var _loop = function _loop() {\n        var ifaceArg = _step5.value;\n        var argName = ifaceArg.name;\n        var typeArg = typeField.args.find(function (arg) {\n          return arg.name === argName;\n        }); // Assert interface field arg exists on object field.\n\n        if (!typeArg) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(type.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, typeField.astNode]);\n          return \"continue\";\n        } // Assert interface field arg type matches object field arg type.\n        // (invariant)\n        // TODO: change to contravariant?\n\n\n        if (!isEqualType(ifaceArg.type, typeArg.type)) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(type.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(typeArg.type), \".\"), [(_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n        } // TODO: validate default values?\n\n      };\n\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      } // Assert additional arguments must not be required.\n\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    var _iterator6 = _createForOfIteratorHelper(typeField.args),\n        _step6;\n\n    try {\n      var _loop2 = function _loop2() {\n        var typeArg = _step6.value;\n        var argName = typeArg.name;\n        var ifaceArg = ifaceField.args.find(function (arg) {\n          return arg.name === argName;\n        });\n\n        if (!ifaceArg && isRequiredArgument(typeArg)) {\n          context.reportError(\"Object field \".concat(type.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [typeArg.astNode, ifaceField.astNode]);\n        }\n      };\n\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        _loop2();\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  var ifaceInterfaces = type.getInterfaces();\n\n  var _iterator7 = _createForOfIteratorHelper(iface.getInterfaces()),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var transitive = _step7.value;\n\n      if (!ifaceInterfaces.includes(transitive)) {\n        context.reportError(transitive === type ? \"Type \".concat(type.name, \" cannot implement \").concat(iface.name, \" because it would create a circular reference.\") : \"Type \".concat(type.name, \" must implement \").concat(transitive.name, \" because it is implemented by \").concat(iface.name, \".\"), [].concat(_toConsumableArray(getAllImplementsInterfaceNodes(iface, transitive)), _toConsumableArray(getAllImplementsInterfaceNodes(type, iface))));\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), [union.astNode].concat(_toConsumableArray(union.extensionASTNodes)));\n  }\n\n  var includedTypeNames = Object.create(null);\n\n  var _iterator8 = _createForOfIteratorHelper(memberTypes),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var memberType = _step8.value;\n\n      if (includedTypeNames[memberType.name]) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n        continue;\n      }\n\n      includedTypeNames[memberType.name] = true;\n\n      if (!isObjectType(memberType)) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), [enumType.astNode].concat(_toConsumableArray(enumType.extensionASTNodes)));\n  }\n\n  var _iterator9 = _createForOfIteratorHelper(enumValues),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var enumValue = _step9.value;\n      // Ensure valid name.\n      validateName(context, enumValue);\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), [inputObj.astNode].concat(_toConsumableArray(inputObj.extensionASTNodes)));\n  } // Ensure the arguments are valid\n\n\n  for (var _i4 = 0, _fields2 = fields; _i4 < _fields2.length; _i4++) {\n    var field = _fields2[_i4];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\"Required input field \".concat(inputObj.name, \".\").concat(field.name, \" cannot be deprecated.\"), [getDeprecatedDirectiveNode(field.astNode), (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = Object.values(inputObj.getFields());\n\n    for (var _i5 = 0, _fields3 = fields; _i5 < _fields3.length; _i5++) {\n      var field = _fields3[_i5];\n\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  var astNode = type.astNode,\n      extensionASTNodes = type.extensionASTNodes;\n  var nodes = astNode != null ? [astNode].concat(_toConsumableArray(extensionASTNodes)) : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(function (typeNode) {\n    var _typeNode$interfaces;\n\n    return (\n      /* c8 ignore next */\n      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []\n    );\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  var astNode = union.astNode,\n      extensionASTNodes = union.extensionASTNodes;\n  var nodes = astNode != null ? [astNode].concat(_toConsumableArray(extensionASTNodes)) : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(function (unionNode) {\n    var _unionNode$types;\n\n    return (\n      /* c8 ignore next */\n      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []\n    );\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function (node) {\n    return node.name.value === GraphQLDeprecatedDirective.name;\n  });\n}","map":{"version":3,"names":["inspect","GraphQLError","OperationTypeNode","isEqualType","isTypeSubTypeOf","isEnumType","isInputObjectType","isInputType","isInterfaceType","isNamedType","isNonNullType","isObjectType","isOutputType","isRequiredArgument","isRequiredInputField","isUnionType","GraphQLDeprecatedDirective","isDirective","isIntrospectionType","assertSchema","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","nodes","_nodes","Array","isArray","filter","Boolean","push","queryType","getQueryType","reportError","astNode","_getOperationTypeNode","getOperationTypeNode","QUERY","mutationType","getMutationType","_getOperationTypeNode2","MUTATION","subscriptionType","getSubscriptionType","_getOperationTypeNode3","SUBSCRIPTION","operation","_flatMap$find","extensionASTNodes","flatMap","schemaNode","_schemaNode$operation","operationTypes","find","operationNode","type","getDirectives","directive","validateName","args","arg","name","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","node","startsWith","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","Object","values","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","field","_field$astNode","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","create","getInterfaces","iface","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","ifaceField","fieldName","typeField","_ifaceField$astNode","_typeField$astNode","ifaceArg","typeArg","_ifaceArg$astNode","_typeArg$astNode","ifaceInterfaces","transitive","includes","union","memberTypes","getTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","enumValue","inputObj","_field$astNode2","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","ofType","fieldType","cycleIndex","undefined","cyclePath","slice","pathStr","fieldObj","pop","typeNode","_typeNode$interfaces","interfaces","ifaceNode","value","typeName","unionNode","_unionNode$types","types","definitionNode","_definitionNode$direc","directives"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/type/validate.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInputType,\n  isInterfaceType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isOutputType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isUnionType,\n} from './definition.mjs';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { assertSchema } from './schema.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(\n      new GraphQLError(message, {\n        nodes: _nodes,\n      }),\n    );\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\n      `Query root type must be Object type, it cannot be ${inspect(\n        queryType,\n      )}.`,\n      (_getOperationTypeNode = getOperationTypeNode(\n        schema,\n        OperationTypeNode.QUERY,\n      )) !== null && _getOperationTypeNode !== void 0\n        ? _getOperationTypeNode\n        : queryType.astNode,\n    );\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError(\n      'Mutation root type must be Object type if provided, it cannot be ' +\n        `${inspect(mutationType)}.`,\n      (_getOperationTypeNode2 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.MUTATION,\n      )) !== null && _getOperationTypeNode2 !== void 0\n        ? _getOperationTypeNode2\n        : mutationType.astNode,\n    );\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError(\n      'Subscription root type must be Object type if provided, it cannot be ' +\n        `${inspect(subscriptionType)}.`,\n      (_getOperationTypeNode3 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.SUBSCRIPTION,\n      )) !== null && _getOperationTypeNode3 !== void 0\n        ? _getOperationTypeNode3\n        : subscriptionType.astNode,\n    );\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (schemaNode) => {\n        var _schemaNode$operation;\n\n        return (\n          /* c8 ignore next */\n          (_schemaNode$operation =\n            schemaNode === null || schemaNode === void 0\n              ? void 0\n              : schemaNode.operationTypes) !== null &&\n            _schemaNode$operation !== void 0\n            ? _schemaNode$operation\n            : []\n        );\n      },\n    )\n    .find((operationNode) => operationNode.operation === operation)) === null ||\n    _flatMap$find === void 0\n    ? void 0\n    : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\n        `Expected directive but got: ${inspect(directive)}.`,\n        directive === null || directive === void 0 ? void 0 : directive.astNode,\n      );\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\n          `The type of @${directive.name}(${arg.name}:) must be Input Type ` +\n            `but got: ${inspect(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(\n          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0\n              ? void 0\n              : _arg$astNode.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs =\n    createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${inspect(type)}.`,\n        type.astNode,\n      );\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\n        `The type of ${type.name}.${field.name} must be Output Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode = field.astNode) === null || _field$astNode === void 0\n          ? void 0\n          : _field$astNode.type,\n      );\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\n          `The type of ${type.name}.${field.name}(${argName}:) must be Input ` +\n            `Type but got: ${inspect(arg.type)}.`,\n          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0\n            ? void 0\n            : _arg$astNode2.type,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(\n          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0\n              ? void 0\n              : _arg$astNode3.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(\n        `Type ${inspect(type)} must only implement Interface types, ` +\n          `it cannot implement ${inspect(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type.name} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\n        `Type ${type.name} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` +\n          `is type ${inspect(typeField.type)}.`,\n        [\n          (_ifaceField$astNode = ifaceField.astNode) === null ||\n          _ifaceField$astNode === void 0\n            ? void 0\n            : _ifaceField$astNode.type,\n          (_typeField$astNode = typeField.astNode) === null ||\n          _typeField$astNode === void 0\n            ? void 0\n            : _typeField$astNode.type,\n        ],\n      );\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${inspect(ifaceArg.type)} but ` +\n            `${type.name}.${fieldName}(${argName}:) is type ` +\n            `${inspect(typeArg.type)}.`,\n          [\n            (_ifaceArg$astNode = ifaceArg.astNode) === null ||\n            _ifaceArg$astNode === void 0\n              ? void 0\n              : _ifaceArg$astNode.type,\n            (_typeArg$astNode = typeArg.astNode) === null ||\n            _typeArg$astNode === void 0\n              ? void 0\n              : _typeArg$astNode.type,\n          ],\n        );\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\n          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType.name} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${inspect(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType.name} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0\n          ? void 0\n          : _field$astNode2.type,\n      );\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\n        [\n          getDeprecatedDirectiveNode(field.astNode),\n          (_field$astNode3 = field.astNode) === null ||\n          _field$astNode3 === void 0\n            ? void 0\n            : _field$astNode3.type,\n        ],\n      );\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\n          context.reportError(\n            `Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const { astNode, extensionASTNodes } = type;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((typeNode) => {\n      var _typeNode$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_typeNode$interfaces = typeNode.interfaces) !== null &&\n          _typeNode$interfaces !== void 0\n          ? _typeNode$interfaces\n          : []\n      );\n    })\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const { astNode, extensionASTNodes } = union;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((unionNode) => {\n      var _unionNode$types;\n\n      return (\n        /* c8 ignore next */\n        (_unionNode$types = unionNode.types) !== null &&\n          _unionNode$types !== void 0\n          ? _unionNode$types\n          : []\n      );\n    })\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0\n    ? void 0\n    : (_definitionNode$direc = definitionNode.directives) === null ||\n      _definitionNode$direc === void 0\n    ? void 0\n    : _definitionNode$direc.find(\n        (node) => node.name.value === GraphQLDeprecatedDirective.name,\n      );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}