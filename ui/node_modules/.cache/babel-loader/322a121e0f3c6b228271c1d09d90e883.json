{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { getNamedType, isInputObjectType, isInterfaceType, isObjectType, isUnionType } from './definition.mjs';\nimport { isDirective, specifiedDirectives } from './directives.mjs';\nimport { __Schema } from './introspection.mjs';\n/**\n * Test if the given value is a GraphQL schema.\n */\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\n\nexport class GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives; // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n\n\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) || devAssert(false, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || devAssert(false, `\"types\" must be Array if provided but got: ${inspect(config.types)}.`);\n    !config.directives || Array.isArray(config.directives) || devAssert(false, '\"directives\" must be Array if provided but got: ' + `${inspect(config.directives)}.`);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if (isDirective(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      typeName || devAssert(false, 'One of the provided types for building the Schema is missing a name.');\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(`Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`);\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType() {\n    return this._queryType;\n  }\n\n  getMutationType() {\n    return this._mutationType;\n  }\n\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation) {\n    switch (operation) {\n      case OperationTypeNode.QUERY:\n        return this.getQueryType();\n\n      case OperationTypeNode.MUTATION:\n        return this.getMutationType();\n\n      case OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap() {\n    return this._typeMap;\n  }\n\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(abstractType) {\n    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0 ? implementations : {\n      objects: [],\n      interfaces: []\n    };\n  }\n\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if (isUnionType(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  }\n\n  getDirectives() {\n    return this._directives;\n  }\n\n  getDirective(name) {\n    return this.getDirectives().find(directive => directive.name === name);\n  }\n\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined\n    };\n  }\n\n}\n\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if (isUnionType(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}","map":{"version":3,"names":["devAssert","inspect","instanceOf","isObjectLike","toObjMap","OperationTypeNode","getNamedType","isInputObjectType","isInterfaceType","isObjectType","isUnionType","isDirective","specifiedDirectives","__Schema","isSchema","schema","GraphQLSchema","assertSchema","Error","constructor","config","_config$extensionASTN","_config$directives","__validationErrors","assumeValid","undefined","types","Array","isArray","directives","description","extensions","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","allReferencedTypes","Set","type","delete","collectReferencedTypes","directive","arg","args","_typeMap","Object","create","_subTypeMap","_implementationsMap","namedType","typeName","name","iface","getInterfaces","implementations","objects","interfaces","push","Symbol","toStringTag","getQueryType","getMutationType","getSubscriptionType","getRootType","operation","QUERY","MUTATION","SUBSCRIPTION","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","getImplementations","interfaceType","isSubType","maybeSubType","map","getDirectives","getDirective","find","toConfig","values","typeSet","has","add","memberType","field","getFields"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/type/schema.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport {\n  getNamedType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isUnionType,\n} from './definition.mjs';\nimport { isDirective, specifiedDirectives } from './directives.mjs';\nimport { __Schema } from './introspection.mjs';\n/**\n * Test if the given value is a GraphQL schema.\n */\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\nexport class GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) ||\n      devAssert(false, 'Must provide configuration object.');\n    !config.types ||\n      Array.isArray(config.types) ||\n      devAssert(\n        false,\n        `\"types\" must be Array if provided but got: ${inspect(config.types)}.`,\n      );\n    !config.directives ||\n      Array.isArray(config.directives) ||\n      devAssert(\n        false,\n        '\"directives\" must be Array if provided but got: ' +\n          `${inspect(config.directives)}.`,\n      );\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\n      _config$extensionASTN !== void 0\n        ? _config$extensionASTN\n        : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives =\n      (_config$directives = config.directives) !== null &&\n      _config$directives !== void 0\n        ? _config$directives\n        : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if (isDirective(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      typeName ||\n        devAssert(\n          false,\n          'One of the provided types for building the Schema is missing a name.',\n        );\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\n          `Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`,\n        );\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType() {\n    return this._queryType;\n  }\n\n  getMutationType() {\n    return this._mutationType;\n  }\n\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation) {\n    switch (operation) {\n      case OperationTypeNode.QUERY:\n        return this.getQueryType();\n\n      case OperationTypeNode.MUTATION:\n        return this.getMutationType();\n\n      case OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap() {\n    return this._typeMap;\n  }\n\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(abstractType) {\n    return isUnionType(abstractType)\n      ? abstractType.getTypes()\n      : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0\n      ? implementations\n      : {\n          objects: [],\n          interfaces: [],\n        };\n  }\n\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if (isUnionType(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  }\n\n  getDirectives() {\n    return this._directives;\n  }\n\n  getDirective(name) {\n    return this.getDirectives().find((directive) => directive.name === name);\n  }\n\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined,\n    };\n  }\n}\n\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if (isUnionType(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}\n"],"mappings":"AAAA,SAASA,SAAT,QAA0B,0BAA1B;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,UAAT,QAA2B,2BAA3B;AACA,SAASC,YAAT,QAA6B,6BAA7B;AACA,SAASC,QAAT,QAAyB,yBAAzB;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AACA,SACEC,YADF,EAEEC,iBAFF,EAGEC,eAHF,EAIEC,YAJF,EAKEC,WALF,QAMO,kBANP;AAOA,SAASC,WAAT,EAAsBC,mBAAtB,QAAiD,kBAAjD;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA;AACA;AACA;;AAEA,OAAO,SAASC,QAAT,CAAkBC,MAAlB,EAA0B;EAC/B,OAAOb,UAAU,CAACa,MAAD,EAASC,aAAT,CAAjB;AACD;AACD,OAAO,SAASC,YAAT,CAAsBF,MAAtB,EAA8B;EACnC,IAAI,CAACD,QAAQ,CAACC,MAAD,CAAb,EAAuB;IACrB,MAAM,IAAIG,KAAJ,CAAW,YAAWjB,OAAO,CAACc,MAAD,CAAS,0BAAtC,CAAN;EACD;;EAED,OAAOA,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAN,CAAoB;EACzB;EACAG,WAAW,CAACC,MAAD,EAAS;IAClB,IAAIC,qBAAJ,EAA2BC,kBAA3B,CADkB,CAGlB;IACA;;;IACA,KAAKC,kBAAL,GAA0BH,MAAM,CAACI,WAAP,KAAuB,IAAvB,GAA8B,EAA9B,GAAmCC,SAA7D,CALkB,CAKsD;;IAExEtB,Y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"},"metadata":{},"sourceType":"module"}