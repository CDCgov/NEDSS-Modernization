{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport { assertInterfaceType, assertNullableType, assertObjectType, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isInputType, isOutputType } from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(false, `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(introspection)}.`); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(schemaIntrospection.types, typeIntrospection => typeIntrospection.name, typeIntrospection => buildType(typeIntrospection)); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = inspect(type);\n    throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection)\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection)\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, valueIntrospection => valueIntrospection.name, valueIntrospection => ({\n        description: valueIntrospection.description,\n        deprecationReason: valueIntrospection.deprecationReason\n      }))\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(`Introspection result missing fields: ${inspect(typeIntrospection)}.`);\n    }\n\n    return keyValMap(typeIntrospection.fields, fieldIntrospection => fieldIntrospection.name, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, inputValue => inputValue.name, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);\n    }\n\n    const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"names":["devAssert","inspect","isObjectLike","keyValMap","parseValue","assertInterfaceType","assertNullableType","assertObjectType","GraphQLEnumType","GraphQLInputObjectType","GraphQLInterfaceType","GraphQLList","GraphQLNonNull","GraphQLObjectType","GraphQLScalarType","GraphQLUnionType","isInputType","isOutputType","GraphQLDirective","introspectionTypes","TypeKind","specifiedScalarTypes","GraphQLSchema","valueFromAST","buildClientSchema","introspection","options","__schema","schemaIntrospection","typeMap","types","typeIntrospection","name","buildType","stdType","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","description","query","mutation","subscription","Object","values","assumeValid","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","getNamedType","typeName","type","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","typeStr","scalarIntrospection","specifiedByURL","buildImplementationsList","implementingIntrospection","interfaces","implementingIntrospectionStr","objectIntrospection","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","unionIntrospectionStr","enumIntrospection","enumValues","enumIntrospectionStr","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","buildInputValueDefMap","fieldIntrospection","buildField","args","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","directiveIntrospection","directiveIntrospectionStr","locations","isRepeatable","slice"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/utilities/buildClientSchema.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport {\n  assertInterfaceType,\n  assertNullableType,\n  assertObjectType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isInputType,\n  isOutputType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  (isObjectLike(introspection) && isObjectLike(introspection.__schema)) ||\n    devAssert(\n      false,\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(\n        introspection,\n      )}.`,\n    ); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(\n    schemaIntrospection.types,\n    (typeIntrospection) => typeIntrospection.name,\n    (typeIntrospection) => buildType(typeIntrospection),\n  ); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType\n    ? getObjectType(schemaIntrospection.queryType)\n    : null;\n  const mutationType = schemaIntrospection.mutationType\n    ? getObjectType(schemaIntrospection.mutationType)\n    : null;\n  const subscriptionType = schemaIntrospection.subscriptionType\n    ? getObjectType(schemaIntrospection.subscriptionType)\n    : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives\n    ? schemaIntrospection.directives.map(buildDirective)\n    : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\n      );\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = inspect(type);\n    throw new Error(\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\n    );\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL,\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (\n      implementingIntrospection.interfaces === null &&\n      implementingIntrospection.kind === TypeKind.INTERFACE\n    ) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\n      );\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection),\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection),\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(\n        enumIntrospection.enumValues,\n        (valueIntrospection) => valueIntrospection.name,\n        (valueIntrospection) => ({\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason,\n        }),\n      ),\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\n        `Introspection result missing fields: ${inspect(typeIntrospection)}.`,\n      );\n    }\n\n    return keyValMap(\n      typeIntrospection.fields,\n      (fieldIntrospection) => fieldIntrospection.name,\n      buildField,\n    );\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\n      );\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\n      );\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args),\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(\n      inputValueIntrospections,\n      (inputValue) => inputValue.name,\n      buildInputValue,\n    );\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\n      );\n    }\n\n    const defaultValue =\n      inputValueIntrospection.defaultValue != null\n        ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type)\n        : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason,\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args),\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}