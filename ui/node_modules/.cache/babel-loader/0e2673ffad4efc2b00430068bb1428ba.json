{"ast":null,"code":"import { isWhiteSpace } from './characterClasses.mjs';\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\n\nexport function dedentBlockStringLines(lines) {\n  var _firstNonEmptyLine2;\n\n  var commonIndent = Number.MAX_SAFE_INTEGER;\n  var firstNonEmptyLine = null;\n  var lastNonEmptyLine = -1;\n\n  for (var i = 0; i < lines.length; ++i) {\n    var _firstNonEmptyLine;\n\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;\n    lastNonEmptyLine = i;\n\n    if (i !== 0 && indent < commonIndent) {\n      commonIndent = indent;\n    }\n  }\n\n  return lines // Remove common indentation from all lines but first.\n  .map(function (line, i) {\n    return i === 0 ? line : line.slice(commonIndent);\n  }) // Remove leading and trailing blank lines.\n  .slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {\n    ++i;\n  }\n\n  return i;\n}\n/**\n * @internal\n */\n\n\nexport function isPrintableAsBlockString(value) {\n  if (value === '') {\n    return true; // empty string is printable\n  }\n\n  var isEmptyLine = true;\n  var hasIndent = false;\n  var hasCommonIndent = true;\n  var seenNonEmptyLine = false;\n\n  for (var i = 0; i < value.length; ++i) {\n    switch (value.codePointAt(i)) {\n      case 0x0000:\n      case 0x0001:\n      case 0x0002:\n      case 0x0003:\n      case 0x0004:\n      case 0x0005:\n      case 0x0006:\n      case 0x0007:\n      case 0x0008:\n      case 0x000b:\n      case 0x000c:\n      case 0x000e:\n      case 0x000f:\n        return false;\n      // Has non-printable characters\n\n      case 0x000d:\n        //  \\r\n        return false;\n      // Has \\r or \\r\\n which will be replaced as \\n\n\n      case 10:\n        //  \\n\n        if (isEmptyLine && !seenNonEmptyLine) {\n          return false; // Has leading new line\n        }\n\n        seenNonEmptyLine = true;\n        isEmptyLine = true;\n        hasIndent = false;\n        break;\n\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        hasIndent || (hasIndent = isEmptyLine);\n        break;\n\n      default:\n        hasCommonIndent && (hasCommonIndent = hasIndent);\n        isEmptyLine = false;\n    }\n  }\n\n  if (isEmptyLine) {\n    return false; // Has trailing empty lines\n  }\n\n  if (hasCommonIndent && seenNonEmptyLine) {\n    return false; // Has internal indent\n  }\n\n  return true;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value, options) {\n  var escapedValue = value.replace(/\"\"\"/g, '\\\\\"\"\"'); // Expand a block string's raw value into independent lines.\n\n  var lines = escapedValue.split(/\\r\\n|[\\n\\r]/g);\n  var isSingleLine = lines.length === 1; // If common indentation is found we can fix some of those cases by adding leading new line\n\n  var forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(function (line) {\n    return line.length === 0 || isWhiteSpace(line.charCodeAt(0));\n  }); // Trailing triple quotes just looks confusing but doesn't force trailing new line\n\n  var hasTrailingTripleQuotes = escapedValue.endsWith('\\\\\"\"\"'); // Trailing quote (single or double) or slash forces trailing new line\n\n  var hasTrailingQuote = value.endsWith('\"') && !hasTrailingTripleQuotes;\n  var hasTrailingSlash = value.endsWith('\\\\');\n  var forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;\n  var printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && ( // add leading and trailing new lines only if it improves readability\n  !isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  var skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));\n\n  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {\n    result += '\\n';\n  }\n\n  result += escapedValue;\n\n  if (printAsMultipleLines || forceTrailingNewline) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result + '\"\"\"';\n}","map":{"version":3,"names":["isWhiteSpace","dedentBlockStringLines","lines","_firstNonEmptyLine2","commonIndent","Number","MAX_SAFE_INTEGER","firstNonEmptyLine","lastNonEmptyLine","i","length","_firstNonEmptyLine","line","indent","leadingWhitespace","map","slice","str","charCodeAt","isPrintableAsBlockString","value","isEmptyLine","hasIndent","hasCommonIndent","seenNonEmptyLine","codePointAt","printBlockString","options","escapedValue","replace","split","isSingleLine","forceLeadingNewLine","every","hasTrailingTripleQuotes","endsWith","hasTrailingQuote","hasTrailingSlash","forceTrailingNewline","printAsMultipleLines","minimize","result","skipLeadingNewLine"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/language/blockString.mjs"],"sourcesContent":["import { isWhiteSpace } from './characterClasses.mjs';\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\n\nexport function dedentBlockStringLines(lines) {\n  var _firstNonEmptyLine2;\n\n  let commonIndent = Number.MAX_SAFE_INTEGER;\n  let firstNonEmptyLine = null;\n  let lastNonEmptyLine = -1;\n\n  for (let i = 0; i < lines.length; ++i) {\n    var _firstNonEmptyLine;\n\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    firstNonEmptyLine =\n      (_firstNonEmptyLine = firstNonEmptyLine) !== null &&\n      _firstNonEmptyLine !== void 0\n        ? _firstNonEmptyLine\n        : i;\n    lastNonEmptyLine = i;\n\n    if (i !== 0 && indent < commonIndent) {\n      commonIndent = indent;\n    }\n  }\n\n  return lines // Remove common indentation from all lines but first.\n    .map((line, i) => (i === 0 ? line : line.slice(commonIndent))) // Remove leading and trailing blank lines.\n    .slice(\n      (_firstNonEmptyLine2 = firstNonEmptyLine) !== null &&\n        _firstNonEmptyLine2 !== void 0\n        ? _firstNonEmptyLine2\n        : 0,\n      lastNonEmptyLine + 1,\n    );\n}\n\nfunction leadingWhitespace(str) {\n  let i = 0;\n\n  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {\n    ++i;\n  }\n\n  return i;\n}\n/**\n * @internal\n */\n\nexport function isPrintableAsBlockString(value) {\n  if (value === '') {\n    return true; // empty string is printable\n  }\n\n  let isEmptyLine = true;\n  let hasIndent = false;\n  let hasCommonIndent = true;\n  let seenNonEmptyLine = false;\n\n  for (let i = 0; i < value.length; ++i) {\n    switch (value.codePointAt(i)) {\n      case 0x0000:\n      case 0x0001:\n      case 0x0002:\n      case 0x0003:\n      case 0x0004:\n      case 0x0005:\n      case 0x0006:\n      case 0x0007:\n      case 0x0008:\n      case 0x000b:\n      case 0x000c:\n      case 0x000e:\n      case 0x000f:\n        return false;\n      // Has non-printable characters\n\n      case 0x000d:\n        //  \\r\n        return false;\n      // Has \\r or \\r\\n which will be replaced as \\n\n\n      case 10:\n        //  \\n\n        if (isEmptyLine && !seenNonEmptyLine) {\n          return false; // Has leading new line\n        }\n\n        seenNonEmptyLine = true;\n        isEmptyLine = true;\n        hasIndent = false;\n        break;\n\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        hasIndent || (hasIndent = isEmptyLine);\n        break;\n\n      default:\n        hasCommonIndent && (hasCommonIndent = hasIndent);\n        isEmptyLine = false;\n    }\n  }\n\n  if (isEmptyLine) {\n    return false; // Has trailing empty lines\n  }\n\n  if (hasCommonIndent && seenNonEmptyLine) {\n    return false; // Has internal indent\n  }\n\n  return true;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value, options) {\n  const escapedValue = value.replace(/\"\"\"/g, '\\\\\"\"\"'); // Expand a block string's raw value into independent lines.\n\n  const lines = escapedValue.split(/\\r\\n|[\\n\\r]/g);\n  const isSingleLine = lines.length === 1; // If common indentation is found we can fix some of those cases by adding leading new line\n\n  const forceLeadingNewLine =\n    lines.length > 1 &&\n    lines\n      .slice(1)\n      .every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0))); // Trailing triple quotes just looks confusing but doesn't force trailing new line\n\n  const hasTrailingTripleQuotes = escapedValue.endsWith('\\\\\"\"\"'); // Trailing quote (single or double) or slash forces trailing new line\n\n  const hasTrailingQuote = value.endsWith('\"') && !hasTrailingTripleQuotes;\n  const hasTrailingSlash = value.endsWith('\\\\');\n  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;\n  const printAsMultipleLines =\n    !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability\n    (!isSingleLine ||\n      value.length > 70 ||\n      forceTrailingNewline ||\n      forceLeadingNewLine ||\n      hasTrailingTripleQuotes);\n  let result = ''; // Format a multi-line block quote to account for leading space.\n\n  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));\n\n  if ((printAsMultipleLines && !skipLeadingNewLine) || forceLeadingNewLine) {\n    result += '\\n';\n  }\n\n  result += escapedValue;\n\n  if (printAsMultipleLines || forceTrailingNewline) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result + '\"\"\"';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}