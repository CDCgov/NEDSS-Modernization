{"ast":null,"code":"/* istanbul ignore file */\n\n/* tslint:disable */\n\n/* eslint-disable */\nimport { ApiError } from './ApiError';\nimport { CancelablePromise } from './CancelablePromise';\n\nconst isDefined = value => {\n  return value !== undefined && value !== null;\n};\n\nconst isString = value => {\n  return typeof value === 'string';\n};\n\nconst isStringWithValue = value => {\n  return isString(value) && value !== '';\n};\n\nconst isBlob = value => {\n  return typeof value === 'object' && typeof value.type === 'string' && typeof value.stream === 'function' && typeof value.arrayBuffer === 'function' && typeof value.constructor === 'function' && typeof value.constructor.name === 'string' && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);\n};\n\nconst isFormData = value => {\n  return value instanceof FormData;\n};\n\nconst base64 = str => {\n  try {\n    return btoa(str);\n  } catch (err) {\n    // @ts-ignore\n    return Buffer.from(str).toString('base64');\n  }\n};\n\nconst getQueryString = params => {\n  const qs = [];\n\n  const append = (key, value) => {\n    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n  };\n\n  const process = (key, value) => {\n    if (isDefined(value)) {\n      if (Array.isArray(value)) {\n        value.forEach(v => {\n          process(key, v);\n        });\n      } else if (typeof value === 'object') {\n        Object.entries(value).forEach(_ref => {\n          let [k, v] = _ref;\n          process(`${key}[${k}]`, v);\n        });\n      } else {\n        append(key, value);\n      }\n    }\n  };\n\n  Object.entries(params).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    process(key, value);\n  });\n\n  if (qs.length > 0) {\n    return `?${qs.join('&')}`;\n  }\n\n  return '';\n};\n\nconst getUrl = (config, options) => {\n  const encoder = config.ENCODE_PATH || encodeURI;\n  const path = options.url.replace('{api-version}', config.VERSION).replace(/{(.*?)}/g, (substring, group) => {\n    var _options$path;\n\n    if ((_options$path = options.path) !== null && _options$path !== void 0 && _options$path.hasOwnProperty(group)) {\n      return encoder(String(options.path[group]));\n    }\n\n    return substring;\n  });\n  const url = `${config.BASE}${path}`;\n\n  if (options.query) {\n    return `${url}${getQueryString(options.query)}`;\n  }\n\n  return url;\n};\n\nconst getFormData = options => {\n  if (options.formData) {\n    const formData = new FormData();\n\n    const process = (key, value) => {\n      if (isString(value) || isBlob(value)) {\n        formData.append(key, value);\n      } else {\n        formData.append(key, JSON.stringify(value));\n      }\n    };\n\n    Object.entries(options.formData).filter(_ref3 => {\n      let [_, value] = _ref3;\n      return isDefined(value);\n    }).forEach(_ref4 => {\n      let [key, value] = _ref4;\n\n      if (Array.isArray(value)) {\n        value.forEach(v => process(key, v));\n      } else {\n        process(key, value);\n      }\n    });\n    return formData;\n  }\n\n  return undefined;\n};\n\nconst resolve = async (options, resolver) => {\n  if (typeof resolver === 'function') {\n    return resolver(options);\n  }\n\n  return resolver;\n};\n\nconst getHeaders = async (config, options) => {\n  const token = await resolve(options, config.TOKEN);\n  const username = await resolve(options, config.USERNAME);\n  const password = await resolve(options, config.PASSWORD);\n  const additionalHeaders = await resolve(options, config.HEADERS);\n  const headers = Object.entries({\n    Accept: 'application/json',\n    ...additionalHeaders,\n    ...options.headers\n  }).filter(_ref5 => {\n    let [_, value] = _ref5;\n    return isDefined(value);\n  }).reduce((headers, _ref6) => {\n    let [key, value] = _ref6;\n    return { ...headers,\n      [key]: String(value)\n    };\n  }, {});\n\n  if (isStringWithValue(token)) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n\n  if (isStringWithValue(username) && isStringWithValue(password)) {\n    const credentials = base64(`${username}:${password}`);\n    headers['Authorization'] = `Basic ${credentials}`;\n  }\n\n  if (options.body) {\n    if (options.mediaType) {\n      headers['Content-Type'] = options.mediaType;\n    } else if (isBlob(options.body)) {\n      headers['Content-Type'] = options.body.type || 'application/octet-stream';\n    } else if (isString(options.body)) {\n      headers['Content-Type'] = 'text/plain';\n    } else if (!isFormData(options.body)) {\n      headers['Content-Type'] = 'application/json';\n    }\n  }\n\n  return new Headers(headers);\n};\n\nconst getRequestBody = options => {\n  if (options.body) {\n    var _options$mediaType;\n\n    if ((_options$mediaType = options.mediaType) !== null && _options$mediaType !== void 0 && _options$mediaType.includes('/json')) {\n      return JSON.stringify(options.body);\n    } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {\n      return options.body;\n    } else {\n      return JSON.stringify(options.body);\n    }\n  }\n\n  return undefined;\n};\n\nexport const sendRequest = async (config, options, url, body, formData, headers, onCancel) => {\n  const controller = new AbortController();\n  const request = {\n    headers,\n    body: body !== null && body !== void 0 ? body : formData,\n    method: options.method,\n    signal: controller.signal\n  };\n\n  if (config.WITH_CREDENTIALS) {\n    request.credentials = config.CREDENTIALS;\n  }\n\n  onCancel(() => controller.abort());\n  return await fetch(url, request);\n};\n\nconst getResponseHeader = (response, responseHeader) => {\n  if (responseHeader) {\n    const content = response.headers.get(responseHeader);\n\n    if (isString(content)) {\n      return content;\n    }\n  }\n\n  return undefined;\n};\n\nconst getResponseBody = async response => {\n  if (response.status !== 204) {\n    try {\n      const contentType = response.headers.get('Content-Type');\n\n      if (contentType) {\n        const isJSON = contentType.toLowerCase().startsWith('application/json');\n\n        if (isJSON) {\n          return await response.json();\n        } else {\n          return await response.text();\n        }\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  return undefined;\n};\n\nconst catchErrorCodes = (options, result) => {\n  const errors = {\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    403: 'Forbidden',\n    404: 'Not Found',\n    500: 'Internal Server Error',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    ...options.errors\n  };\n  const error = errors[result.status];\n\n  if (error) {\n    throw new ApiError(options, result, error);\n  }\n\n  if (!result.ok) {\n    throw new ApiError(options, result, 'Generic Error');\n  }\n};\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\n\n\nexport const request = (config, options) => {\n  return new CancelablePromise(async (resolve, reject, onCancel) => {\n    try {\n      const url = getUrl(config, options);\n      const formData = getFormData(options);\n      const body = getRequestBody(options);\n      const headers = await getHeaders(config, options);\n\n      if (!onCancel.isCancelled) {\n        const response = await sendRequest(config, options, url, body, formData, headers, onCancel);\n        const responseBody = await getResponseBody(response);\n        const responseHeader = getResponseHeader(response, options.responseHeader);\n        const result = {\n          url,\n          ok: response.ok,\n          status: response.status,\n          statusText: response.statusText,\n          body: responseHeader !== null && responseHeader !== void 0 ? responseHeader : responseBody\n        };\n        catchErrorCodes(options, result);\n        resolve(result.body);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n};","map":{"version":3,"names":["ApiError","CancelablePromise","isDefined","value","undefined","isString","isStringWithValue","isBlob","type","stream","arrayBuffer","constructor","name","test","Symbol","toStringTag","isFormData","FormData","base64","str","btoa","err","Buffer","from","toString","getQueryString","params","qs","append","key","push","encodeURIComponent","String","process","Array","isArray","forEach","v","Object","entries","k","length","join","getUrl","config","options","encoder","ENCODE_PATH","encodeURI","path","url","replace","VERSION","substring","group","hasOwnProperty","BASE","query","getFormData","formData","JSON","stringify","filter","_","resolve","resolver","getHeaders","token","TOKEN","username","USERNAME","password","PASSWORD","additionalHeaders","HEADERS","headers","Accept","reduce","credentials","body","mediaType","Headers","getRequestBody","includes","sendRequest","onCancel","controller","AbortController","request","method","signal","WITH_CREDENTIALS","CREDENTIALS","abort","fetch","getResponseHeader","response","responseHeader","content","get","getResponseBody","status","contentType","isJSON","toLowerCase","startsWith","json","text","error","console","catchErrorCodes","result","errors","ok","reject","isCancelled","responseBody","statusText"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/src/generated/core/request.ts"],"sourcesContent":["/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport { ApiError } from './ApiError';\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\nimport { CancelablePromise } from './CancelablePromise';\nimport type { OnCancel } from './CancelablePromise';\nimport type { OpenAPIConfig } from './OpenAPI';\n\nconst isDefined = <T>(value: T | null | undefined): value is Exclude<T, null | undefined> => {\n    return value !== undefined && value !== null;\n};\n\nconst isString = (value: any): value is string => {\n    return typeof value === 'string';\n};\n\nconst isStringWithValue = (value: any): value is string => {\n    return isString(value) && value !== '';\n};\n\nconst isBlob = (value: any): value is Blob => {\n    return (\n        typeof value === 'object' &&\n        typeof value.type === 'string' &&\n        typeof value.stream === 'function' &&\n        typeof value.arrayBuffer === 'function' &&\n        typeof value.constructor === 'function' &&\n        typeof value.constructor.name === 'string' &&\n        /^(Blob|File)$/.test(value.constructor.name) &&\n        /^(Blob|File)$/.test(value[Symbol.toStringTag])\n    );\n};\n\nconst isFormData = (value: any): value is FormData => {\n    return value instanceof FormData;\n};\n\nconst base64 = (str: string): string => {\n    try {\n        return btoa(str);\n    } catch (err) {\n        // @ts-ignore\n        return Buffer.from(str).toString('base64');\n    }\n};\n\nconst getQueryString = (params: Record<string, any>): string => {\n    const qs: string[] = [];\n\n    const append = (key: string, value: any) => {\n        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n    };\n\n    const process = (key: string, value: any) => {\n        if (isDefined(value)) {\n            if (Array.isArray(value)) {\n                value.forEach(v => {\n                    process(key, v);\n                });\n            } else if (typeof value === 'object') {\n                Object.entries(value).forEach(([k, v]) => {\n                    process(`${key}[${k}]`, v);\n                });\n            } else {\n                append(key, value);\n            }\n        }\n    };\n\n    Object.entries(params).forEach(([key, value]) => {\n        process(key, value);\n    });\n\n    if (qs.length > 0) {\n        return `?${qs.join('&')}`;\n    }\n\n    return '';\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n    const encoder = config.ENCODE_PATH || encodeURI;\n\n    const path = options.url\n        .replace('{api-version}', config.VERSION)\n        .replace(/{(.*?)}/g, (substring: string, group: string) => {\n            if (options.path?.hasOwnProperty(group)) {\n                return encoder(String(options.path[group]));\n            }\n            return substring;\n        });\n\n    const url = `${config.BASE}${path}`;\n    if (options.query) {\n        return `${url}${getQueryString(options.query)}`;\n    }\n    return url;\n};\n\nconst getFormData = (options: ApiRequestOptions): FormData | undefined => {\n    if (options.formData) {\n        const formData = new FormData();\n\n        const process = (key: string, value: any) => {\n            if (isString(value) || isBlob(value)) {\n                formData.append(key, value);\n            } else {\n                formData.append(key, JSON.stringify(value));\n            }\n        };\n\n        Object.entries(options.formData)\n            .filter(([_, value]) => isDefined(value))\n            .forEach(([key, value]) => {\n                if (Array.isArray(value)) {\n                    value.forEach(v => process(key, v));\n                } else {\n                    process(key, value);\n                }\n            });\n\n        return formData;\n    }\n    return undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nconst resolve = async <T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> => {\n    if (typeof resolver === 'function') {\n        return (resolver as Resolver<T>)(options);\n    }\n    return resolver;\n};\n\nconst getHeaders = async (config: OpenAPIConfig, options: ApiRequestOptions): Promise<Headers> => {\n    const token = await resolve(options, config.TOKEN);\n    const username = await resolve(options, config.USERNAME);\n    const password = await resolve(options, config.PASSWORD);\n    const additionalHeaders = await resolve(options, config.HEADERS);\n\n    const headers = Object.entries({\n        Accept: 'application/json',\n        ...additionalHeaders,\n        ...options.headers,\n    })\n        .filter(([_, value]) => isDefined(value))\n        .reduce((headers, [key, value]) => ({\n            ...headers,\n            [key]: String(value),\n        }), {} as Record<string, string>);\n\n    if (isStringWithValue(token)) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    if (isStringWithValue(username) && isStringWithValue(password)) {\n        const credentials = base64(`${username}:${password}`);\n        headers['Authorization'] = `Basic ${credentials}`;\n    }\n\n    if (options.body) {\n        if (options.mediaType) {\n            headers['Content-Type'] = options.mediaType;\n        } else if (isBlob(options.body)) {\n            headers['Content-Type'] = options.body.type || 'application/octet-stream';\n        } else if (isString(options.body)) {\n            headers['Content-Type'] = 'text/plain';\n        } else if (!isFormData(options.body)) {\n            headers['Content-Type'] = 'application/json';\n        }\n    }\n\n    return new Headers(headers);\n};\n\nconst getRequestBody = (options: ApiRequestOptions): any => {\n    if (options.body) {\n        if (options.mediaType?.includes('/json')) {\n            return JSON.stringify(options.body)\n        } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {\n            return options.body;\n        } else {\n            return JSON.stringify(options.body);\n        }\n    }\n    return undefined;\n};\n\nexport const sendRequest = async (\n    config: OpenAPIConfig,\n    options: ApiRequestOptions,\n    url: string,\n    body: any,\n    formData: FormData | undefined,\n    headers: Headers,\n    onCancel: OnCancel\n): Promise<Response> => {\n    const controller = new AbortController();\n\n    const request: RequestInit = {\n        headers,\n        body: body ?? formData,\n        method: options.method,\n        signal: controller.signal,\n    };\n\n    if (config.WITH_CREDENTIALS) {\n        request.credentials = config.CREDENTIALS;\n    }\n\n    onCancel(() => controller.abort());\n\n    return await fetch(url, request);\n};\n\nconst getResponseHeader = (response: Response, responseHeader?: string): string | undefined => {\n    if (responseHeader) {\n        const content = response.headers.get(responseHeader);\n        if (isString(content)) {\n            return content;\n        }\n    }\n    return undefined;\n};\n\nconst getResponseBody = async (response: Response): Promise<any> => {\n    if (response.status !== 204) {\n        try {\n            const contentType = response.headers.get('Content-Type');\n            if (contentType) {\n                const isJSON = contentType.toLowerCase().startsWith('application/json');\n                if (isJSON) {\n                    return await response.json();\n                } else {\n                    return await response.text();\n                }\n            }\n        } catch (error) {\n            console.error(error);\n        }\n    }\n    return undefined;\n};\n\nconst catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {\n    const errors: Record<number, string> = {\n        400: 'Bad Request',\n        401: 'Unauthorized',\n        403: 'Forbidden',\n        404: 'Not Found',\n        500: 'Internal Server Error',\n        502: 'Bad Gateway',\n        503: 'Service Unavailable',\n        ...options.errors,\n    }\n\n    const error = errors[result.status];\n    if (error) {\n        throw new ApiError(options, result, error);\n    }\n\n    if (!result.ok) {\n        throw new ApiError(options, result, 'Generic Error');\n    }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions): CancelablePromise<T> => {\n    return new CancelablePromise(async (resolve, reject, onCancel) => {\n        try {\n            const url = getUrl(config, options);\n            const formData = getFormData(options);\n            const body = getRequestBody(options);\n            const headers = await getHeaders(config, options);\n\n            if (!onCancel.isCancelled) {\n                const response = await sendRequest(config, options, url, body, formData, headers, onCancel);\n                const responseBody = await getResponseBody(response);\n                const responseHeader = getResponseHeader(response, options.responseHeader);\n\n                const result: ApiResult = {\n                    url,\n                    ok: response.ok,\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: responseHeader ?? responseBody,\n                };\n\n                catchErrorCodes(options, result);\n\n                resolve(result.body);\n            }\n        } catch (error) {\n            reject(error);\n        }\n    });\n};\n"],"mappings":"AAAA;;AACA;;AACA;AACA,SAASA,QAAT,QAAyB,YAAzB;AAGA,SAASC,iBAAT,QAAkC,qBAAlC;;AAIA,MAAMC,SAAS,GAAOC,KAAJ,IAA2E;EACzF,OAAOA,KAAK,KAAKC,SAAV,IAAuBD,KAAK,KAAK,IAAxC;AACH,CAFD;;AAIA,MAAME,QAAQ,GAAIF,KAAD,IAAiC;EAC9C,OAAO,OAAOA,KAAP,KAAiB,QAAxB;AACH,CAFD;;AAIA,MAAMG,iBAAiB,GAAIH,KAAD,IAAiC;EACvD,OAAOE,QAAQ,CAACF,KAAD,CAAR,IAAmBA,KAAK,KAAK,EAApC;AACH,CAFD;;AAIA,MAAMI,MAAM,GAAIJ,KAAD,IAA+B;EAC1C,OACI,OAAOA,KAAP,KAAiB,QAAjB,IACA,OAAOA,KAAK,CAACK,IAAb,KAAsB,QADtB,IAEA,OAAOL,KAAK,CAACM,MAAb,KAAwB,UAFxB,IAGA,OAAON,KAAK,CAACO,WAAb,KAA6B,UAH7B,IAIA,OAAOP,KAAK,CAACQ,WAAb,KAA6B,UAJ7B,IAKA,OAAOR,KAAK,CAACQ,WAAN,CAAkBC,IAAzB,KAAkC,QALlC,IAMA,gBAAgBC,IAAhB,CAAqBV,KAAK,CAACQ,WAAN,CAAkBC,IAAvC,CANA,IAOA,gBAAgBC,IAAhB,CAAqBV,KAAK,CAACW,MAAM,CAACC,WAAR,CAA1B,CARJ;AAUH,CAXD;;AAaA,MAAMC,UAAU,GAAIb,KAAD,IAAmC;EAClD,OAAOA,KAAK,YAAYc,QAAxB;AACH,CAFD;;AAIA,MAAMC,MAAM,GAAIC,GAAD,IAAyB;EACpC,IAAI;IACA,OAAOC,IAAI,CAACD,GAAD,CAAX;EACH,CAFD,CAEE,OAAOE,GAAP,EAAY;IACV;IACA,OAAOC,MAAM,CAACC,IAAP,CAAYJ,GAAZ,EAAiBK,QAAjB,CAA0B,QAA1B,CAAP;EACH;AACJ,CAPD;;AASA,MAAMC,cAAc,GAAIC,MAAD,IAAyC;EAC5D,MAAMC,EAAY,GAAG,EAArB;;EAEA,MAAMC,MAAM,GAAG,CAACC,GAAD,EAAc1B,KAAd,KAA6B;IACxCwB,EAAE,CAACG,IAAH,CAAS,GAAEC,kBAAkB,CAACF,GAAD,CAAM,IAAGE,kBAAkB,CAACC,MAAM,CAAC7B,KAAD,CAAP,CAAgB,EAAxE;EACH,CAFD;;EAIA,MAAM8B,OAAO,GAAG,CAACJ,GAAD,EAAc1B,KAAd,KAA6B;IACzC,IAAID,SAAS,CAACC,KAAD,CAAb,EAAsB;MAClB,IAAI+B,KAAK,CAACC,OAAN,CAAchC,KAAd,CAAJ,EAA0B;QACtBA,KAAK,CAACiC,OAAN,CAAcC,CAAC,IAAI;UACfJ,OAAO,CAACJ,GAAD,EAAMQ,CAAN,CAAP;QACH,CAFD;MAGH,CAJD,MAIO,IAAI,OAAOlC,KAAP,KAAiB,QAArB,EAA+B;QAClCmC,MAAM,CAACC,OAAP,CAAepC,KAAf,EAAsBiC,OAAtB,CAA8B,QAAY;UAAA,IAAX,CAACI,CAAD,EAAIH,CAAJ,CAAW;UACtCJ,OAAO,CAAE,GAAEJ,GAAI,IAAGW,CAAE,GAAb,EAAiBH,CAAjB,CAAP;QACH,CAFD;MAGH,CAJM,MAIA;QACHT,MAAM,CAACC,GAAD,EAAM1B,KAAN,CAAN;MACH;IACJ;EACJ,CAdD;;EAgBAmC,MAAM,CAACC,OAAP,CAAeb,MAAf,EAAuBU,OAAvB,CAA+B,SAAkB;IAAA,IAAjB,CAACP,GAAD,EAAM1B,KAAN,CAAiB;IAC7C8B,OAAO,CAACJ,GAAD,EAAM1B,KAAN,CAAP;EACH,CAFD;;EAIA,IAAIwB,EAAE,CAACc,MAAH,GAAY,CAAhB,EAAmB;IACf,OAAQ,IAAGd,EAAE,CAACe,IAAH,CAAQ,GAAR,CAAa,EAAxB;EACH;;EAED,OAAO,EAAP;AACH,CAhCD;;AAkCA,MAAMC,MAAM,GAAG,CAACC,MAAD,EAAwBC,OAAxB,KAA+D;EAC1E,MAAMC,OAAO,GAAGF,MAAM,CAACG,WAAP,IAAsBC,SAAtC;EAEA,MAAMC,IAAI,GAAGJ,OAAO,CAACK,GAAR,CACRC,OADQ,CACA,eADA,EACiBP,MAAM,CAACQ,OADxB,EAERD,OAFQ,CAEA,UAFA,EAEY,CAACE,SAAD,EAAoBC,KAApB,KAAsC;IAAA;;IACvD,qBAAIT,OAAO,CAACI,IAAZ,0CAAI,cAAcM,cAAd,CAA6BD,KAA7B,CAAJ,EAAyC;MACrC,OAAOR,OAAO,CAACd,MAAM,CAACa,OAAO,CAACI,IAAR,CAAaK,KAAb,CAAD,CAAP,CAAd;IACH;;IACD,OAAOD,SAAP;EACH,CAPQ,CAAb;EASA,MAAMH,GAAG,GAAI,GAAEN,MAAM,CAACY,IAAK,GAAEP,IAAK,EAAlC;;EACA,IAAIJ,OAAO,CAACY,KAAZ,EAAmB;IACf,OAAQ,GAAEP,GAAI,GAAEzB,cAAc,CAACoB,OAAO,CAACY,KAAT,CAAgB,EAA9C;EACH;;EACD,OAAOP,GAAP;AACH,CAjBD;;AAmBA,MAAMQ,WAAW,GAAIb,OAAD,IAAsD;EACtE,IAAIA,OAAO,CAACc,QAAZ,EAAsB;IAClB,MAAMA,QAAQ,GAAG,IAAI1C,QAAJ,EAAjB;;IAEA,MAAMgB,OAAO,GAAG,CAACJ,GAAD,EAAc1B,KAAd,KAA6B;MACzC,IAAIE,QAAQ,CAACF,KAAD,CAAR,IAAmBI,MAAM,CAACJ,KAAD,CAA7B,EAAsC;QAClCwD,QAAQ,CAAC/B,MAAT,CAAgBC,GAAhB,EAAqB1B,KAArB;MACH,CAFD,MAEO;QACHwD,QAAQ,CAAC/B,MAAT,CAAgBC,GAAhB,EAAqB+B,IAAI,CAACC,SAAL,CAAe1D,KAAf,CAArB;MACH;IACJ,CAND;;IAQAmC,MAAM,CAACC,OAAP,CAAeM,OAAO,CAACc,QAAvB,EACKG,MADL,CACY;MAAA,IAAC,CAACC,CAAD,EAAI5D,KAAJ,CAAD;MAAA,OAAgBD,SAAS,CAACC,KAAD,CAAzB;IAAA,CADZ,EAEKiC,OAFL,CAEa,SAAkB;MAAA,IAAjB,CAACP,GAAD,EAAM1B,KAAN,CAAiB;;MACvB,IAAI+B,KAAK,CAACC,OAAN,CAAchC,KAAd,CAAJ,EAA0B;QACtBA,KAAK,CAACiC,OAAN,CAAcC,CAAC,IAAIJ,OAAO,CAACJ,GAAD,EAAMQ,CAAN,CAA1B;MACH,CAFD,MAEO;QACHJ,OAAO,CAACJ,GAAD,EAAM1B,KAAN,CAAP;MACH;IACJ,CARL;IAUA,OAAOwD,QAAP;EACH;;EACD,OAAOvD,SAAP;AACH,CAzBD;;AA6BA,MAAM4D,OAAO,GAAG,OAAUnB,OAAV,EAAsCoB,QAAtC,KAA6F;EACzG,IAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;IAChC,OAAQA,QAAD,CAA0BpB,OAA1B,CAAP;EACH;;EACD,OAAOoB,QAAP;AACH,CALD;;AAOA,MAAMC,UAAU,GAAG,OAAOtB,MAAP,EAA8BC,OAA9B,KAA+E;EAC9F,MAAMsB,KAAK,GAAG,MAAMH,OAAO,CAACnB,OAAD,EAAUD,MAAM,CAACwB,KAAjB,CAA3B;EACA,MAAMC,QAAQ,GAAG,MAAML,OAAO,CAACnB,OAAD,EAAUD,MAAM,CAAC0B,QAAjB,CAA9B;EACA,MAAMC,QAAQ,GAAG,MAAMP,OAAO,CAACnB,OAAD,EAAUD,MAAM,CAAC4B,QAAjB,CAA9B;EACA,MAAMC,iBAAiB,GAAG,MAAMT,OAAO,CAACnB,OAAD,EAAUD,MAAM,CAAC8B,OAAjB,CAAvC;EAEA,MAAMC,OAAO,GAAGrC,MAAM,CAACC,OAAP,CAAe;IAC3BqC,MAAM,EAAE,kBADmB;IAE3B,GAAGH,iBAFwB;IAG3B,GAAG5B,OAAO,CAAC8B;EAHgB,CAAf,EAKXb,MALW,CAKJ;IAAA,IAAC,CAACC,CAAD,EAAI5D,KAAJ,CAAD;IAAA,OAAgBD,SAAS,CAACC,KAAD,CAAzB;EAAA,CALI,EAMX0E,MANW,CAMJ,CAACF,OAAD;IAAA,IAAU,CAAC9C,GAAD,EAAM1B,KAAN,CAAV;IAAA,OAA4B,EAChC,GAAGwE,OAD6B;MAEhC,CAAC9C,GAAD,GAAOG,MAAM,CAAC7B,KAAD;IAFmB,CAA5B;EAAA,CANI,EASR,EATQ,CAAhB;;EAWA,IAAIG,iBAAiB,CAAC6D,KAAD,CAArB,EAA8B;IAC1BQ,OAAO,CAAC,eAAD,CAAP,GAA4B,UAASR,KAAM,EAA3C;EACH;;EAED,IAAI7D,iBAAiB,CAAC+D,QAAD,CAAjB,IAA+B/D,iBAAiB,CAACiE,QAAD,CAApD,EAAgE;IAC5D,MAAMO,WAAW,GAAG5D,MAAM,CAAE,GAAEmD,QAAS,IAAGE,QAAS,EAAzB,CAA1B;IACAI,OAAO,CAAC,eAAD,CAAP,GAA4B,SAAQG,WAAY,EAAhD;EACH;;EAED,IAAIjC,OAAO,CAACkC,IAAZ,EAAkB;IACd,IAAIlC,OAAO,CAACmC,SAAZ,EAAuB;MACnBL,OAAO,CAAC,cAAD,CAAP,GAA0B9B,OAAO,CAACmC,SAAlC;IACH,CAFD,MAEO,IAAIzE,MAAM,CAACsC,OAAO,CAACkC,IAAT,CAAV,EAA0B;MAC7BJ,OAAO,CAAC,cAAD,CAAP,GAA0B9B,OAAO,CAACkC,IAAR,CAAavE,IAAb,IAAqB,0BAA/C;IACH,CAFM,MAEA,IAAIH,QAAQ,CAACwC,OAAO,CAACkC,IAAT,CAAZ,EAA4B;MAC/BJ,OAAO,CAAC,cAAD,CAAP,GAA0B,YAA1B;IACH,CAFM,MAEA,IAAI,CAAC3D,UAAU,CAAC6B,OAAO,CAACkC,IAAT,CAAf,EAA+B;MAClCJ,OAAO,CAAC,cAAD,CAAP,GAA0B,kBAA1B;IACH;EACJ;;EAED,OAAO,IAAIM,OAAJ,CAAYN,OAAZ,CAAP;AACH,CAvCD;;AAyCA,MAAMO,cAAc,GAAIrC,OAAD,IAAqC;EACxD,IAAIA,OAAO,CAACkC,IAAZ,EAAkB;IAAA;;IACd,0BAAIlC,OAAO,CAACmC,SAAZ,+CAAI,mBAAmBG,QAAnB,CAA4B,OAA5B,CAAJ,EAA0C;MACtC,OAAOvB,IAAI,CAACC,SAAL,CAAehB,OAAO,CAACkC,IAAvB,CAAP;IACH,CAFD,MAEO,IAAI1E,QAAQ,CAACwC,OAAO,CAACkC,IAAT,CAAR,IAA0BxE,MAAM,CAACsC,OAAO,CAACkC,IAAT,CAAhC,IAAkD/D,UAAU,CAAC6B,OAAO,CAACkC,IAAT,CAAhE,EAAgF;MACnF,OAAOlC,OAAO,CAACkC,IAAf;IACH,CAFM,MAEA;MACH,OAAOnB,IAAI,CAACC,SAAL,CAAehB,OAAO,CAACkC,IAAvB,CAAP;IACH;EACJ;;EACD,OAAO3E,SAAP;AACH,CAXD;;AAaA,OAAO,MAAMgF,WAAW,GAAG,OACvBxC,MADuB,EAEvBC,OAFuB,EAGvBK,GAHuB,EAIvB6B,IAJuB,EAKvBpB,QALuB,EAMvBgB,OANuB,EAOvBU,QAPuB,KAQH;EACpB,MAAMC,UAAU,GAAG,IAAIC,eAAJ,EAAnB;EAEA,MAAMC,OAAoB,GAAG;IACzBb,OADyB;IAEzBI,IAAI,EAAEA,IAAF,aAAEA,IAAF,cAAEA,IAAF,GAAUpB,QAFW;IAGzB8B,MAAM,EAAE5C,OAAO,CAAC4C,MAHS;IAIzBC,MAAM,EAAEJ,UAAU,CAACI;EAJM,CAA7B;;EAOA,IAAI9C,MAAM,CAAC+C,gBAAX,EAA6B;IACzBH,OAAO,CAACV,WAAR,GAAsBlC,MAAM,CAACgD,WAA7B;EACH;;EAEDP,QAAQ,CAAC,MAAMC,UAAU,CAACO,KAAX,EAAP,CAAR;EAEA,OAAO,MAAMC,KAAK,CAAC5C,GAAD,EAAMsC,OAAN,CAAlB;AACH,CAzBM;;AA2BP,MAAMO,iBAAiB,GAAG,CAACC,QAAD,EAAqBC,cAArB,KAAqE;EAC3F,IAAIA,cAAJ,EAAoB;IAChB,MAAMC,OAAO,GAAGF,QAAQ,CAACrB,OAAT,CAAiBwB,GAAjB,CAAqBF,cAArB,CAAhB;;IACA,IAAI5F,QAAQ,CAAC6F,OAAD,CAAZ,EAAuB;MACnB,OAAOA,OAAP;IACH;EACJ;;EACD,OAAO9F,SAAP;AACH,CARD;;AAUA,MAAMgG,eAAe,GAAG,MAAOJ,QAAP,IAA4C;EAChE,IAAIA,QAAQ,CAACK,MAAT,KAAoB,GAAxB,EAA6B;IACzB,IAAI;MACA,MAAMC,WAAW,GAAGN,QAAQ,CAACrB,OAAT,CAAiBwB,GAAjB,CAAqB,cAArB,CAApB;;MACA,IAAIG,WAAJ,EAAiB;QACb,MAAMC,MAAM,GAAGD,WAAW,CAACE,WAAZ,GAA0BC,UAA1B,CAAqC,kBAArC,CAAf;;QACA,IAAIF,MAAJ,EAAY;UACR,OAAO,MAAMP,QAAQ,CAACU,IAAT,EAAb;QACH,CAFD,MAEO;UACH,OAAO,MAAMV,QAAQ,CAACW,IAAT,EAAb;QACH;MACJ;IACJ,CAVD,CAUE,OAAOC,KAAP,EAAc;MACZC,OAAO,CAACD,KAAR,CAAcA,KAAd;IACH;EACJ;;EACD,OAAOxG,SAAP;AACH,CAjBD;;AAmBA,MAAM0G,eAAe,GAAG,CAACjE,OAAD,EAA6BkE,MAA7B,KAAyD;EAC7E,MAAMC,MAA8B,GAAG;IACnC,KAAK,aAD8B;IAEnC,KAAK,cAF8B;IAGnC,KAAK,WAH8B;IAInC,KAAK,WAJ8B;IAKnC,KAAK,uBAL8B;IAMnC,KAAK,aAN8B;IAOnC,KAAK,qBAP8B;IAQnC,GAAGnE,OAAO,CAACmE;EARwB,CAAvC;EAWA,MAAMJ,KAAK,GAAGI,MAAM,CAACD,MAAM,CAACV,MAAR,CAApB;;EACA,IAAIO,KAAJ,EAAW;IACP,MAAM,IAAI5G,QAAJ,CAAa6C,OAAb,EAAsBkE,MAAtB,EAA8BH,KAA9B,CAAN;EACH;;EAED,IAAI,CAACG,MAAM,CAACE,EAAZ,EAAgB;IACZ,MAAM,IAAIjH,QAAJ,CAAa6C,OAAb,EAAsBkE,MAAtB,EAA8B,eAA9B,CAAN;EACH;AACJ,CApBD;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMvB,OAAO,GAAG,CAAI5C,MAAJ,EAA2BC,OAA3B,KAAgF;EACnG,OAAO,IAAI5C,iBAAJ,CAAsB,OAAO+D,OAAP,EAAgBkD,MAAhB,EAAwB7B,QAAxB,KAAqC;IAC9D,IAAI;MACA,MAAMnC,GAAG,GAAGP,MAAM,CAACC,MAAD,EAASC,OAAT,CAAlB;MACA,MAAMc,QAAQ,GAAGD,WAAW,CAACb,OAAD,CAA5B;MACA,MAAMkC,IAAI,GAAGG,cAAc,CAACrC,OAAD,CAA3B;MACA,MAAM8B,OAAO,GAAG,MAAMT,UAAU,CAACtB,MAAD,EAASC,OAAT,CAAhC;;MAEA,IAAI,CAACwC,QAAQ,CAAC8B,WAAd,EAA2B;QACvB,MAAMnB,QAAQ,GAAG,MAAMZ,WAAW,CAACxC,MAAD,EAASC,OAAT,EAAkBK,GAAlB,EAAuB6B,IAAvB,EAA6BpB,QAA7B,EAAuCgB,OAAvC,EAAgDU,QAAhD,CAAlC;QACA,MAAM+B,YAAY,GAAG,MAAMhB,eAAe,CAACJ,QAAD,CAA1C;QACA,MAAMC,cAAc,GAAGF,iBAAiB,CAACC,QAAD,EAAWnD,OAAO,CAACoD,cAAnB,CAAxC;QAEA,MAAMc,MAAiB,GAAG;UACtB7D,GADsB;UAEtB+D,EAAE,EAAEjB,QAAQ,CAACiB,EAFS;UAGtBZ,MAAM,EAAEL,QAAQ,CAACK,MAHK;UAItBgB,UAAU,EAAErB,QAAQ,CAACqB,UAJC;UAKtBtC,IAAI,EAAEkB,cAAF,aAAEA,cAAF,cAAEA,cAAF,GAAoBmB;QALF,CAA1B;QAQAN,eAAe,CAACjE,OAAD,EAAUkE,MAAV,CAAf;QAEA/C,OAAO,CAAC+C,MAAM,CAAChC,IAAR,CAAP;MACH;IACJ,CAvBD,CAuBE,OAAO6B,KAAP,EAAc;MACZM,MAAM,CAACN,KAAD,CAAN;IACH;EACJ,CA3BM,CAAP;AA4BH,CA7BM"},"metadata":{},"sourceType":"module"}