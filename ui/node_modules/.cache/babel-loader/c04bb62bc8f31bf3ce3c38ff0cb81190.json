{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport { GraphQLIncludeDirective, GraphQLSkipDirective } from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n  var fields = new Map();\n  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set());\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n  var subFieldNodes = new Map();\n  var visitedFragmentNames = new Set();\n\n  var _iterator = _createForOfIteratorHelper(fieldNodes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.selectionSet) {\n        collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  var _iterator2 = _createForOfIteratorHelper(selectionSet.selections),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var selection = _step2.value;\n\n      switch (selection.kind) {\n        case Kind.FIELD:\n          {\n            if (!shouldIncludeNode(variableValues, selection)) {\n              continue;\n            }\n\n            var name = getFieldEntryKey(selection);\n            var fieldList = fields.get(name);\n\n            if (fieldList !== undefined) {\n              fieldList.push(selection);\n            } else {\n              fields.set(name, [selection]);\n            }\n\n            break;\n          }\n\n        case Kind.INLINE_FRAGMENT:\n          {\n            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n              continue;\n            }\n\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n            break;\n          }\n\n        case Kind.FRAGMENT_SPREAD:\n          {\n            var fragName = selection.name.value;\n\n            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n              continue;\n            }\n\n            visitedFragmentNames.add(fragName);\n            var fragment = fragments[fragName];\n\n            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n              continue;\n            }\n\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n            break;\n          }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\n\nfunction shouldIncludeNode(variableValues, node) {\n  var skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  var include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  var typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  var conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}","map":{"version":3,"names":["Kind","isAbstractType","GraphQLIncludeDirective","GraphQLSkipDirective","typeFromAST","getDirectiveValues","collectFields","schema","fragments","variableValues","runtimeType","selectionSet","fields","Map","collectFieldsImpl","Set","collectSubfields","returnType","fieldNodes","subFieldNodes","visitedFragmentNames","node","selections","selection","kind","FIELD","shouldIncludeNode","name","getFieldEntryKey","fieldList","get","undefined","push","set","INLINE_FRAGMENT","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","value","has","add","fragment","skip","if","include","type","typeConditionNode","typeCondition","conditionalType","isSubType","alias"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/execution/collectFields.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport {\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n} from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(\n    GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}