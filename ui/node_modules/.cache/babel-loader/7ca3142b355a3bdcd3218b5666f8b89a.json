{"ast":null,"code":"import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude, isNonNullObject, compact } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function defaultDataIdFromObject(_a, context) {\n  var __typename = _a.__typename,\n      id = _a.id,\n      _id = _a._id;\n\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = id !== void 0 ? {\n        id: id\n      } : _id !== void 0 ? {\n        _id: _id\n      } : void 0;\n    }\n\n    if (id === void 0) id = _id;\n\n    if (id !== void 0) {\n      return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n}\nvar defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  canonizeResults: false\n};\nexport function normalizeConfig(config) {\n  return compact(defaultConfig, config);\n}\nexport function shouldCanonizeResults(config) {\n  var value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (isNonNullObject(result)) {\n    return isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n\n      return true;\n    });\n  }\n\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\nexport var isArray = function (a) {\n  return Array.isArray(a);\n};","map":{"version":3,"mappings":"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","names":["isReference","isField","DeepMerger","resultKeyNameFromField","shouldInclude","isNonNullObject","compact","hasOwn","Object","prototype","hasOwnProperty","defaultDataIdFromObject","_a","context","__typename","id","_id","keyObject","concat","JSON","stringify","defaultConfig","dataIdFromObject","addTypename","resultCaching","canonizeResults","normalizeConfig","config","shouldCanonizeResults","value","getTypenameFromStoreObject","store","objectOrReference","get","__ref","TypeOrFieldNameRegExp","fieldNameFromStoreName","storeFieldName","match","selectionSetMatchesResult","selectionSet","result","variables","isArray","every","item","selections","field","key","call","storeValueIsStoreObject","makeProcessedFieldsMerger","a"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@apollo/src/cache/inmemory/helpers.ts"],"sourcesContent":["import { SelectionSetNode } from 'graphql';\n\nimport {\n  NormalizedCache,\n  InMemoryCacheConfig,\n} from './types';\n\nimport { KeyFieldsContext } from './policies';\n\nimport {\n  Reference,\n  isReference,\n  StoreValue,\n  StoreObject,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n} from '../../utilities';\n\nexport const {\n  hasOwnProperty: hasOwn,\n} = Object.prototype;\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext,\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n         id !== void 0 ? {  id } :\n        _id !== void 0 ? { _id } :\n        void 0;\n    }\n    // If there is no object.id, fall back to object._id.\n    if (id === void 0) id = _id;\n    if (id !== void 0) {\n      return `${__typename}:${(\n        typeof id === \"number\" ||\n        typeof id === \"string\"\n      ) ? id : JSON.stringify(id)}`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">,\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference,\n): string | undefined {\n  return isReference(objectOrReference)\n    ? store.get(objectOrReference.__ref, \"__typename\") as string\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>,\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result)\n      ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables))\n      : selectionSet.selections.every(field => {\n        if (isField(field) && shouldInclude(field, variables)) {\n          const key = resultKeyNameFromField(field);\n          return hasOwn.call(result, key) &&\n            (!field.selectionSet ||\n             selectionSetMatchesResult(field.selectionSet, result[key], variables));\n        }\n        // If the selection has been skipped with @skip(true) or\n        // @include(false), it should not count against the matching. If\n        // the selection is not a field, it must be a fragment (inline or\n        // named). We will determine if selectionSetMatchesResult for that\n        // fragment when we get to it, so for now we return true.\n        return true;\n      });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue,\n): value is StoreObject {\n  return isNonNullObject(value) &&\n    !isReference(value) &&\n    !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger;\n}\n\nexport const isArray = (a: any): a is any[] | readonly any[] => Array.isArray(a)\n"]},"metadata":{},"sourceType":"module"}