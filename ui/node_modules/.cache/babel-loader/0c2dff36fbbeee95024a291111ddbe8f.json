{"ast":null,"code":"import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\n\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while (set = setsToVisit.pop()) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while (node = nodesToVisit.pop()) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: () => false,\n\n        Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n\n}","map":{"version":3,"names":["Kind","visit","TypeInfo","visitWithTypeInfo","ASTValidationContext","constructor","ast","onError","_ast","_fragments","undefined","_fragmentSpreads","Map","_recursivelyReferencedFragments","_onError","Symbol","toStringTag","reportError","error","getDocument","getFragment","name","fragments","Object","create","defNode","definitions","kind","FRAGMENT_DEFINITION","value","getFragmentSpreads","node","spreads","get","setsToVisit","set","pop","selection","selections","FRAGMENT_SPREAD","push","selectionSet","getRecursivelyReferencedFragments","operation","collectedNames","nodesToVisit","spread","fragName","fragment","SDLValidationContext","schema","_schema","getSchema","ValidationContext","typeInfo","_typeInfo","_variableUsages","_recursiveVariableUsages","getVariableUsages","usages","newUsages","VariableDefinition","Variable","variable","type","getInputType","defaultValue","getDefaultValue","getRecursiveVariableUsages","frag","concat","getType","getParentType","getParentInputType","getFieldDef","getDirective","getArgument","getEnumValue"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/validation/ValidationContext.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}