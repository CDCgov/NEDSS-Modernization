{"ast":null,"code":"import _defineProperty from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n\nvar _defKindToExtKind;\n\nimport { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport { isEnumType, isInputObjectType, isInterfaceType, isObjectType, isScalarType, isUnionType } from '../../type/definition.mjs';\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\n\nexport function PossibleTypeExtensionsRule(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  var _iterator = _createForOfIteratorHelper(context.getDocument().definitions),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var def = _step.value;\n\n      if (isTypeDefinitionNode(def)) {\n        definedTypes[def.name.value] = def;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    var expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        var kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new GraphQLError(\"Cannot extend non-\".concat(kindStr, \" type \\\"\").concat(typeName, \"\\\".\"), {\n          nodes: defNode ? [defNode, node] : node\n        }));\n      }\n    } else {\n      var allTypeNames = Object.keys(_objectSpread(_objectSpread({}, definedTypes), schema === null || schema === void 0 ? void 0 : schema.getTypeMap()));\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(\"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes), {\n        nodes: node.name\n      }));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}","map":{"version":3,"names":["didYouMean","inspect","invariant","suggestionList","GraphQLError","Kind","isTypeDefinitionNode","isEnumType","isInputObjectType","isInterfaceType","isObjectType","isScalarType","isUnionType","PossibleTypeExtensionsRule","context","schema","getSchema","definedTypes","Object","create","getDocument","definitions","def","name","value","ScalarTypeExtension","checkExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","node","typeName","defNode","existingType","getType","expectedKind","defKindToExtKind","kind","typeToExtKind","kindStr","extensionKindToTypeName","reportError","nodes","allTypeNames","keys","getTypeMap","suggestedTypes","SCALAR_TYPE_DEFINITION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_DEFINITION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","ENUM_TYPE_DEFINITION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","type"],"sources":["/Users/henryclark/Desktop/Enquizit/Project/NEDSS-Modernization-1/ui/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}