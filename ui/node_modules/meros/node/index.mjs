async function e(e,t){const n=e.headers["content-type"];if(!n||!~n.indexOf("multipart/mixed"))return e;const i=n.indexOf("boundary="),r=i+9,o=n.indexOf(";",r);return async function*(e,t,n){const i=!n||!n.multiple;let r=Buffer.byteLength(t),o=Buffer.alloc(0),s=!0,f=[];e:for await(const n of e){const e=n.indexOf(t);let c=o.byteLength;for(o=Buffer.concat([o,n]),~e?c+=e:c=o.indexOf(t),f=[];~c;){const e=o.slice(0,c),n=o.slice(c+r);if(s)s=!1,t="\r\n"+t,r+=2;else{const t={},r=e.indexOf("\r\n\r\n")+4,s=String(o.slice(0,r)).trim().split("\r\n");let c;for(;c=s.shift();)c=c.split(": "),t[c.shift().toLowerCase()]=c.join(": ");const l=e.lastIndexOf("\r\n",r);let d=e.slice(r,l>-1?void 0:l),a=!1;if(c=t["content-type"],c&&~c.indexOf("application/json"))try{d=JSON.parse(String(d)),a=!0}catch(e){}if(c={headers:t,body:d,json:a},i?yield c:f.push(c),45===n[0]&&45===n[1])break e}o=n,c=o.indexOf(t)}f.length&&(yield f)}f.length&&(yield f)}(e,`--${~i?n.substring(r,o>-1?o:void 0).replace(/['"]/g,"").trim():"-"}`,t)}export{e as meros};